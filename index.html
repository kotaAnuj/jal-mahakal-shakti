<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Water Distribution Management Pro</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"/>
  <link rel="stylesheet" href="./css/app.css"/>
    
    .btn.warning:hover {
      background: #ffe0b2;
    }
    
    .water-level-container {
      background: linear-gradient(180deg, #e3f2fd 0%, #bbdefb 100%);
      border-radius: 12px;
      padding: 16px;
      margin: 12px 0;
      position: relative;
      overflow: hidden;
    }
    
    .water-tank-visual {
      width: 100%;
      height: 200px;
      position: relative;
      background: #fff;
      border-radius: 8px;
      border: 3px solid #0277bd;
      overflow: hidden;
      box-shadow: inset 0 2px 8px rgba(0,0,0,.1);
    }
    
    .water-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(180deg, #03a9f4 0%, #0288d1 100%);
      transition: height .3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: 700;
      font-size: 24px;
      text-shadow: 0 2px 4px rgba(0,0,0,.2);
    }
    
    .water-level-slider {
      width: 100%;
      margin-top: 12px;
      -webkit-appearance: none;
      appearance: none;
      height: 8px;
      border-radius: 4px;
      background: #e0e0e0;
      outline: none;
    }
    
    .water-level-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #0288d1;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,.2);
    }
    
    .water-level-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #0288d1;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,.2);
      border: none;
    }
    
    .household-stats {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      border-radius: 12px;
      padding: 16px;
      margin: 12px 0;
    }
    
    .household-stats h4 {
      color: #fff;
      border-bottom: 2px solid rgba(255,255,255,.3);
      padding-bottom: 8px;
      margin-bottom: 12px;
    }
    
    .stat-big {
      text-align: center;
      margin: 16px 0;
    }
    
    .stat-big-number {
      font-size: 48px;
      font-weight: 700;
      line-height: 1;
      margin-bottom: 4px;
      text-shadow: 0 2px 8px rgba(0,0,0,.3);
    }
    
    .stat-big-label {
      font-size: 13px;
      opacity: .9;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .stat-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 12px;
      background: rgba(255,255,255,.1);
      border-radius: 8px;
      margin: 8px 0;
    }
    
    .stat-row .label {
      color: rgba(255,255,255,.8);
    }
    
    .stat-row .value {
      color: #fff;
      font-weight: 700;
    }
    
    .valve-hierarchy {
      margin: 12px 0;
    }
    
    .valve-item {
      background: #f8f9fa;
      border-left: 4px solid var(--accent);
      padding: 12px;
      border-radius: 8px;
      margin: 8px 0;
    }
    
    .valve-item.main {
      border-left-color: var(--primary);
      background: #e3f2fd;
    }
    
    .valve-item.sub {
      margin-left: 24px;
      border-left-color: var(--success);
    }
    
    .valve-item.closed {
      opacity: .6;
      border-left-color: var(--danger);
    }
    
    .valve-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .valve-item-title {
      font-weight: 700;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .valve-item-status {
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 6px;
      font-weight: 600;
    }
    
    .valve-item-status.open {
      background: #e9f7ee;
      color: var(--success);
    }
    
    .valve-item-status.closed {
      background: #fdeaea;
      color: var(--danger);
    }
    
    .valve-item-info {
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
    }
    
    .modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      background: rgba(18,22,28,.35);
      backdrop-filter: blur(2px);
    }
    
    .modal.active {
      display: flex;
    }
    
    .modal-content {
      width: min(720px, 95vw);
      max-height: 85vh;
      background: #fff;
      border: 1px solid var(--line);
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,.2);
      overflow: hidden;
      animation: modalIn .3s cubic-bezier(.4,0,.2,1);
      display: flex;
      flex-direction: column;
    }
    
    @keyframes modalIn {
      from { opacity: 0; transform: scale(.95); }
      to { opacity: 1; transform: scale(1); }
    }
    
    .modal-header {
      padding: 16px 18px;
      border-bottom: 1px solid var(--line);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #fafbfc;
      flex-shrink: 0;
    }
    
    .modal-header h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 700;
    }
    
    .close-x {
      border: none;
      background: #f5f7fa;
      width: 32px;
      height: 32px;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all .2s;
    }
    
    .close-x:hover {
      background: #e8ecf0;
    }
    
    .modal-body {
      padding: 18px;
      overflow-y: auto;
      flex: 1;
    }
    
    .form-row {
      margin-bottom: 12px;
    }
    
    .form-row label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px;
      font-weight: 600;
    }
    
    .form-row input, .form-row select, .form-row textarea {
      width: 100%;
      padding: 11px 12px;
      border: 1px solid var(--line);
      border-radius: 10px;
      font-size: 13px;
      color: var(--text);
      background: #fff;
      outline: none;
      transition: all .2s;
      font-family: inherit;
    }
    
    .form-row textarea {
      min-height: 60px;
      resize: vertical;
    }
    
    .form-row input:focus, .form-row select:focus, .form-row textarea:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(30,136,229,.1);
    }
    
    .form-row .error {
      font-size: 11px;
      color: var(--danger);
      margin-top: 4px;
    }
    
    .modal-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 16px;
    }
    
    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 3000;
      background: #fff;
      border: 1px solid var(--line);
      color: var(--text);
      padding: 12px 16px;
      border-radius: 10px;
      box-shadow: 0 12px 24px rgba(0,0,0,.15);
      font-size: 13px;
      font-weight: 600;
      display: none;
      animation: toastIn .3s cubic-bezier(.4,0,.2,1);
    }
    
    @keyframes toastIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .zoom {
      position: absolute;
      bottom: 20px;
      left: 20px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 1000;
    }
    
    .zoom .tool-btn {
      width: 44px;
      height: 44px;
      border-radius: 10px;
      font-size: 18px;
    }
    
    .manage-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .manage-item {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 12px;
      background: #fff;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }
    
    .manage-item-info {
      min-width: 0;
      flex: 1;
    }
    
    .manage-item-title {
      font-weight: 700;
      color: var(--text);
      margin-bottom: 4px;
    }
    
    .manage-item-meta {
      color: var(--muted);
      font-size: 12px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .manage-item-actions {
      display: flex;
      gap: 6px;
      flex-shrink: 0;
    }
    
    .manage-item-actions .btn {
      margin: 0;
      width: auto;
      padding: 8px 12px;
      font-size: 12px;
    }
    
    .tab-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .tab-buttons .btn {
      margin: 0;
    }
    
    .connection-status {
      position: absolute;
      top: 16px;
      right: 60px;
      z-index: 1100;
      background: var(--panel);
      padding: 8px 12px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,.08);
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      font-weight: 600;
    }
    
    .connection-status.connected {
      color: var(--success);
    }
    
    .connection-status.disconnected {
      color: var(--danger);
    }
    
    .connection-status .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }
    
    .connection-status.connected .dot {
      background: var(--success);
    }
    
    .connection-status.disconnected .dot {
      background: var(--danger);
    }
    
    .loading-overlay {
      position: fixed;
      inset: 0;
      background: rgba(255,255,255,.95);
      z-index: 5000;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 16px;
    }
    
    .loading-overlay.active {
      display: flex;
    }
    
    .spinner {
      width: 48px;
      height: 48px;
      border: 4px solid var(--line);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Hover Tooltip Styles */
    .hover-tooltip {
      position: absolute;
      background: rgba(20, 20, 30, 0.95);
      color: white;
      padding: 12px 16px;
      border-radius: 10px;
      font-size: 12px;
      font-weight: 500;
      z-index: 2000;
      pointer-events: none;
      max-width: 320px;
      min-width: 200px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      transform: translateY(-10px);
      opacity: 0;
      transition: opacity 0.2s, transform 0.2s;
    }
    
    .hover-tooltip.active {
      opacity: 1;
      transform: translateY(0);
    }
    
    .hover-tooltip .tooltip-title {
      font-weight: 700;
      font-size: 14px;
      margin-bottom: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .hover-tooltip .tooltip-section {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .hover-tooltip .tooltip-section-title {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: rgba(255, 255, 255, 0.6);
      font-weight: 700;
      margin-bottom: 6px;
    }
    
    .hover-tooltip .tooltip-row {
      display: flex;
      justify-content: space-between;
      margin-top: 6px;
      padding: 4px 0;
    }
    
    .hover-tooltip .tooltip-label {
      color: rgba(255, 255, 255, 0.7);
      font-size: 11px;
    }
    
    .hover-tooltip .tooltip-value {
      color: white;
      font-weight: 700;
      font-size: 12px;
    }
    
    .hover-tooltip .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 6px;
      box-shadow: 0 0 8px currentColor;
    }
    
    .hover-tooltip .status-active {
      background: #4caf50;
      color: #4caf50;
    }
    
    .hover-tooltip .status-inactive {
      background: #f44336;
      color: #f44336;
    }
    
    .hover-tooltip .live-badge {
      display: inline-block;
      background: #4caf50;
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 9px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      animation: pulse 2s infinite;
    }
    
    .hover-tooltip .status-active {
      background: #4caf50;
    }
    
    .hover-tooltip .status-inactive {
      background: #f44336;
    }
    
    /* Supply Dashboard Styles */
    .supply-dashboard {
  position: absolute;
  bottom: 20px;
  right: 20px;
  width: 320px;
  background: var(--panel);
  border-radius: 12px;
  box-shadow: 0 6px 20px rgba(0,0,0,.08);
  border: 1px solid var(--line);
  z-index: 1000;
  overflow: hidden;
  transition: right 0.3s cubic-bezier(.4,0,.2,1);
}

.supply-dashboard.shifted {
  right: 500px; /* Moves left when sidebar is open */
}
    .supply-dashboard-header {
      padding: 12px 16px;
      background: #fafbfc;
      border-bottom: 1px solid var(--line);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .supply-dashboard-title {
      font-size: 14px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .supply-dashboard-body {
      padding: 16px;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .supply-region {
      margin-bottom: 16px;
      border: 1px solid var(--line);
      border-radius: 8px;
      overflow: hidden;
    }
    
    .supply-region-header {
      padding: 10px 12px;
      background: #f8f9fa;
      border-bottom: 1px solid var(--line);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .supply-region-name {
      font-weight: 600;
      font-size: 13px;
    }
    
    .supply-region-stats {
      display: flex;
      gap: 12px;
      font-size: 11px;
    }
    
    .supply-region-body {
      padding: 12px;
    }
    
    .supply-valve {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px dashed #eef2f5;
    }
    
    .supply-valve:last-child {
      border-bottom: none;
    }
    
    .supply-valve-info {
      flex: 1;
    }
    
    .supply-valve-name {
      font-weight: 600;
      font-size: 12px;
    }
    
    .supply-valve-meta {
      font-size: 10px;
      color: var(--muted);
    }
    
    .supply-valve-status {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: 600;
    }
    
    .supply-valve-status.open {
      background: #e9f7ee;
      color: var(--success);
    }
    
    .supply-valve-status.closed {
      background: #fdeaea;
      color: var(--danger);
    }
    
    .supply-valve-flow {
      font-size: 12px;
      font-weight: 700;
      color: var(--primary);
    }
    
    .supply-summary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      border-radius: 8px;
      padding: 12px;
      margin-top: 12px;
    }
    
    .supply-summary-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 6px;
    }
    
    .supply-summary-row:last-child {
      margin-bottom: 0;
    }
    
    .supply-summary-label {
      font-size: 11px;
      opacity: .9;
    }
    
    .supply-summary-value {
      font-size: 12px;
      font-weight: 700;
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
      .search {
        width: calc(100% - 100px);
      }
      
      .sidebar {
        width: 90vw;
      }
      
      .supply-dashboard {
        width: 90vw;
        right: 5vw;
        bottom: 80px;
      }
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <canvas id="canvas"></canvas>

  <!-- Hover Tooltip -->
  <div id="hoverTooltip" class="hover-tooltip"></div>

  <!-- Supply Dashboard -->
  <div class="supply-dashboard" id="supplyDashboard">
    <div class="supply-dashboard-header">
      <div class="supply-dashboard-title">
        <i class="fas fa-tachometer-alt"></i> Supply Overview
      </div>
      <button class="close-x" id="toggleSupplyDashboard">
        <i class="fas fa-chevron-down"></i>
      </button>
    </div>
    <div class="supply-dashboard-body" id="supplyDashboardBody">
      <!-- Content will be populated by JavaScript -->
    </div>
  </div>

  <div class="connection-status" id="connectionStatus">
    <div class="dot"></div>
    <span id="statusText">Connecting...</span>
  </div>

  <div class="loading-overlay" id="loadingOverlay">
    <div class="spinner"></div>
    <div style="font-weight:600;color:var(--text)">Loading System...</div>
  </div>



  <div class="toolbar">
    
    <button id="toolPipeline" class="tool-btn active" title="Draw pipeline"><i class="fas fa-drafting-compass"></i></button>
    <button id="toolTank" class="tool-btn" title="Add tank"><i class="fas fa-water"></i></button>
    <button id="toolValve" class="tool-btn" title="Add valve"><i class="fas fa-cog"></i></button>
    <button id="toolErase" class="tool-btn" title="Erase pipeline segment"><i class="fas fa-eraser"></i></button>
    <button id="toolManage" class="tool-btn" title="Manage"><i class="fas fa-list"></i></button>
  <!-- <button id="toolImport" class="tool-btn" title="Import data"><i class="fas fa-upload"></i></button> 
    <button id="toolClear" class="tool-btn" title="Clear all"><i class="fas fa-trash"></i></button> -->
    
    <div class="toolbar-separator"></div>
    
    <button id="layerStreet" class="tool-btn layer active" title="Street Map"><i class="fas fa-map"></i></button>
    <button id="layerSatellite" class="tool-btn layer" title="Satellite View"><i class="fas fa-satellite"></i></button>
    <button id="layerDark" class="tool-btn layer" title="Dark Mode"><i class="fas fa-moon"></i></button>
  </div>

  <div class="search">
    <div class="search-bar">
      <i class="fas fa-magnifying-glass" style="color:var(--muted)"></i>
      <input id="searchInput" type="text" placeholder="Search devices, places, or areas..." autocomplete="off"/>
      <button id="searchBtn" class="icon-btn" title="Search"><i class="fas fa-arrow-right"></i></button>
    </div>
    <div class="suggestions" id="suggestions" style="display:none">
      <div class="suggest-list" id="suggestList"></div>
    </div>
  </div>

  <div class="zoom">
    <button id="zoomIn" class="tool-btn" title="Zoom in"><i class="fas fa-plus"></i></button>
    <button id="zoomOut" class="tool-btn" title="Zoom out"><i class="fas fa-minus"></i></button>
  </div>

  <div class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <div class="sidebar-title" id="sidebarTitle"><i class="fas fa-info-circle"></i> Details</div>
      <button class="close-x" id="closeSidebar" title="Close"><i class="fas fa-xmark"></i></button>
    </div>
    <div class="sidebar-body" id="sidebarBody"></div>
  </div>

  <!-- Tank Modal -->
  <div class="modal" id="tankModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="tankModalTitle">Add Tank</h3>
        <button class="close-x" data-close="tankModal"><i class="fas fa-xmark"></i></button>
      </div>
      <div class="modal-body">
  <div class="form-row">
    <label>Tank ID * (Unique identifier)</label>
    <input id="tankId" placeholder="TANK-001" maxlength="50"/>
    <div class="error" id="tankIdError"></div>
  </div>
  <div class="form-row">
    <label>Device ID <small style="color: var(--muted);">(Link to ESP32 device, e.g., DEVICE_001)</small></label>
    <input id="tankDeviceId" placeholder="DEVICE_001" maxlength="50"/>
    <div style="font-size: 11px; color: var(--muted); margin-top: 4px;">
      <i class="fas fa-info-circle"></i> Enter the device ID from your ESP32 (e.g., DEVICE_001). This links the tank to live ultrasonic sensor data.
    </div>
  </div>
  <div class="form-row"><label>Name *</label><input id="tankName" placeholder="OHSR Tank 1"/></div>
  <div class="form-row">
    <label>Type *</label>
    <select id="tankType">
      <option value="OHSR">OHSR (Overhead Storage Reservoir)</option>
      <option value="GSR">GSR (Ground Storage Reservoir)</option>
      <option value="ESR">ESR (Elevated Storage Reservoir)</option>
    </select>
  </div>
  <div class="form-row">
    <label>Shape *</label>
    <select id="tankShape">
      <option value="cylinder">Cylinder (OHSR/ESR)</option>
      <option value="cuboid">Cuboid (GSR)</option>
    </select>
  </div>
  
  <!-- Cylinder dimensions -->
  <div id="cylinderDimensions">
    <div class="form-row">
      <label>Diameter (m) *</label>
      <input id="tankDiameter" type="number" step="0.1" placeholder="10" value="10"/>
    </div>
  <div class="form-row">
    <label>Height (m) *</label>
    <input id="tankHeight" type="number" step="0.1" placeholder="10" value="10"/>
  </div>
  <div class="form-row">
    <label>Sensor Height (m) <small style="color: var(--muted);">(Distance from sensor to tank bottom)</small></label>
    <input id="tankSensorHeight" type="number" step="0.1" placeholder="Same as height" value="10"/>
    <div style="font-size: 11px; color: var(--muted); margin-top: 4px;">
      <i class="fas fa-info-circle"></i> Height of ultrasonic sensor from tank bottom. Defaults to tank height if not specified.
    </div>
  </div>
  </div>
  
  <!-- Cuboid dimensions -->
  <div id="cuboidDimensions" style="display: none;">
    <div class="form-row">
      <label>Length (m) *</label>
      <input id="tankLength" type="number" step="0.1" placeholder="10" value="10"/>
    </div>
    <div class="form-row">
      <label>Breadth (m) *</label>
      <input id="tankBreadth" type="number" step="0.1" placeholder="10" value="10"/>
    </div>
    <div class="form-row">
      <label>Height (m) *</label>
      <input id="tankHeightCuboid" type="number" step="0.1" placeholder="10" value="10"/>
    </div>
  </div>
  
  <div class="form-row">
    <label>Capacity (L) * <small style="color: var(--muted);">(Auto-calculated or manual)</small></label>
    <input id="tankCapacity" type="number" placeholder="20000"/>
    <button type="button" class="btn primary" id="calculateCapacity" style="margin-top: 8px;">
      <i class="fas fa-calculator"></i> Calculate from Dimensions
    </button>
  </div>
  
  <div class="form-row">
    <label>Current Water Level (m) *</label>
    <input id="tankWaterLevel" type="number" step="0.1" placeholder="8.5" max="10"/>
  </div>
  <!-- NEW: Connected Main Valves Section -->
  <div class="form-row">
    <label>Connected Main Valves * (Select all main valves connected to this tank)</label>
    <div style="border: 1px solid var(--line); border-radius: 10px; padding: 12px; background: #f8f9fa; max-height: 200px; overflow-y: auto;" id="mainValvesList">
      <div style="text-align: center; color: var(--muted); padding: 20px;">
        Loading main valves...
      </div>
    </div>
    <div style="font-size: 11px; color: var(--muted); margin-top: 6px;">
      <i class="fas fa-info-circle"></i> Select which main valves receive water from this tank
    </div>
  </div>
  
  <div class="form-row"><label>State</label><input id="tankState" placeholder="Telangana"/></div>
  <div class="form-row"><label>District</label><input id="tankDistrict" placeholder="Mulugu"/></div>
  <div class="form-row"><label>Mandal</label><input id="tankMandal" placeholder="Eturunagaram"/></div>
  <div class="form-row"><label>Habitation</label><input id="tankHabitation" placeholder="Ellishettypalle"/></div>
  <div class="form-row"><label>Latitude *</label><input id="tankLat" type="number" step="0.000001" placeholder="Right-click map"/></div>
  <div class="form-row"><label>Longitude *</label><input id="tankLng" type="number" step="0.000001" placeholder="Right-click map"/></div>
  <div class="modal-actions">
    <button id="saveTank" class="btn success"><i class="fas fa-save"></i> Save</button>
    <button class="btn" data-close="tankModal"><i class="fas fa-times"></i> Cancel</button>
  </div>
</div>
    </div>
  </div>

  <!-- Valve Modal -->
  <div class="modal" id="valveModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="valveModalTitle">Add Valve</h3>
        <button class="close-x" data-close="valveModal"><i class="fas fa-xmark"></i></button>
      </div>
      <div class="modal-body">
        <div class="form-row">
          <label>Valve ID * (Unique)</label>
          <input id="valveId" placeholder="VALVE-001" maxlength="50"/>
          <div class="error" id="valveIdError"></div>
        </div>
        <div class="form-row"><label>Name *</label><input id="valveName" placeholder="Main Gate Valve"/></div>
        <div class="form-row"><label>Type *</label>
          <select id="valveType">
            <option value="STRAIGHT">Straight</option>
            <option value="ELBOW">Elbow</option>
            <option value="TEE">Tee</option>
          </select>
        </div>
        <div class="form-row"><label>Category *</label>
          <select id="valveCategory">
            <option value="main">Main</option>
            <option value="sub">Sub</option>
          </select>
        </div>
        <div class="form-row" id="parentValveRow" style="display:none">
          <label>Parent Main Valve</label>
          <select id="parentValve"></select>
        </div>
<div class="form-row"><label>Households *</label><input id="valveHouseholds" type="number" placeholder="10"/></div>
<div class="form-row"><label>Flow Rate (L/min) *</label><input id="valveFlowRate" type="number" placeholder="50"/></div>        <div class="form-row"><label>Mandal</label><input id="valveMandal" placeholder="Eturunagaram"/></div>
        <div class="form-row"><label>Habitation</label><input id="valveHabitation" placeholder="Central Area"/></div>
        <div class="form-row"><label>Latitude *</label><input id="valveLat" type="number" step="0.000001" placeholder="Right-click map"/></div>
        <div class="form-row"><label>Longitude *</label><input id="valveLng" type="number" step="0.000001" placeholder="Right-click map"/></div>
        <div class="modal-actions">
          <button id="saveValve" class="btn success"><i class="fas fa-save"></i> Save</button>
          <button class="btn" data-close="valveModal"><i class="fas fa-times"></i> Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Pipeline Modal -->
  <div class="modal" id="pipelineModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="pipelineModalTitle">Pipeline Details</h3>
        <button class="close-x" data-close="pipelineModal"><i class="fas fa-xmark"></i></button>
      </div>
      <div class="modal-body">
        <div class="form-row"><label>Name *</label><input id="pipelineName" placeholder="Main Supply Line"/></div>
        <div class="form-row"><label>Type *</label>
          <select id="pipelineType">
            <option value="PVC">PVC</option>
            <option value="HDPE">HDPE</option>
            <option value="DI">Ductile Iron</option>
          </select>
        </div>
        <div class="form-row"><label>Diameter (mm) *</label><input id="pipelineDiameter" type="number" placeholder="200"/></div>
        <div class="form-row"><label>Capacity (L/min) *</label><input id="pipelineCapacity" type="number" placeholder="800"/></div>
        <div class="form-row"><label>Start point</label><input id="pipelineStart" placeholder="Main Tank"/></div>
        <div class="form-row"><label>End point</label><input id="pipelineEnd" placeholder="Main Valve"/></div>
        <div class="form-row"><label>Notes</label><textarea id="pipelineNotes" placeholder="Optional notes"></textarea></div>
        <div class="modal-actions">
          <button id="savePipeline" class="btn success"><i class="fas fa-save"></i> Save</button>
          <button class="btn danger" id="deleteThisPipeline"><i class="fas fa-trash"></i> Delete</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Manage Modal -->




  <!-- History Modal -->
  <div class="modal" id="historyModal">
    <div class="modal-content modal-content--wide">
      <div class="modal-header">
        <h3 id="historyModalTitle">Device History</h3>
        <button class="close-x" data-close="historyModal"><i class="fas fa-xmark"></i></button>
      </div>
      <div class="modal-body">
        <div class="card card--flush">
          <div class="filter-grid">
            <div class="form-row form-row--compact">
              <label>Start Date</label>
              <input type="date" id="historyStartDate">
            </div>
            <div class="form-row form-row--compact">
              <label>End Date</label>
              <input type="date" id="historyEndDate">
            </div>
            <div class="form-row form-row--compact">
              <label>Time Range (Hours)</label>
              <select id="historyTimeRange">
                <option value="">All Day</option>
                <option value="0-6">12 AM - 6 AM</option>
                <option value="6-12">6 AM - 12 PM</option>
                <option value="12-18">12 PM - 6 PM</option>
                <option value="18-24">6 PM - 12 AM</option>
              </select>
            </div>
            <button class="btn primary btn--compact" id="filterHistoryBtn">
              <i class="fas fa-filter"></i> Filter
            </button>
          </div>
          <div class="card" id="historyDeviceCard" style="display:none">
            <h4><i class="fas fa-satellite-dish"></i> FIELD DEVICE</h4>
            <div class="row"><span class="label">Device ID</span><span class="value" id="historyDeviceId">â€”</span></div>
            <div class="row"><span class="label">Last Update</span><span class="value" id="historyDeviceLastUpdate">â€”</span></div>
            <div class="row"><span class="label">Distance</span><span class="value" id="historyDeviceDistance">â€”</span></div>
            <div class="row"><span class="label">Readings</span><span class="value" id="historyDeviceReadings">â€”</span></div>
          </div>
        </div>
        
        <div class="card">
          <div class="flex-between u-mb-12">
            <h4 style="margin: 0;"><i class="fas fa-clock-rotate-left"></i> HISTORICAL DATA</h4>
            <div style="display: flex; gap: 8px;">
              <button class="btn primary btn--compact" id="syncHistoryBtn" onclick="syncAllDeviceDataToHistory()" title="Sync all device data to history">
                <i class="fas fa-sync"></i> Sync Data
              </button>
              <button class="btn success btn--compact" id="exportHistoryBtn">
                <i class="fas fa-download"></i> Export CSV
              </button>
            </div>
          </div>
          <div id="historyContent" class="history-content">
            <div class="empty-state">
              <i class="fas fa-spinner fa-spin"></i>
              <div>Loading history...</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>





  <div class="modal" id="manageModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Manage</h3>
        <button class="close-x" data-close="manageModal"><i class="fas fa-xmark"></i></button>
      </div>
      <div class="modal-body">
        <div class="tab-buttons">
          <button class="btn primary" data-tab="tanks"><i class="fas fa-water"></i> Tanks</button>
          <button class="btn" data-tab="valves"><i class="fas fa-cog"></i> Valves</button>
          <button class="btn" data-tab="pipelines"><i class="fas fa-pipe"></i> Pipelines</button>
          <button class="btn" data-tab="data"><i class="fas fa-database"></i> Data</button>
        </div>
        <div id="manageContent"></div>
      </div>
    </div>
  </div>

  <input id="importFile" type="file" accept=".json" style="display:none"/>
  <div id="toast" class="toast"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
     
  <script type="module">
    import { Tank, Valve, Pipeline } from './js/models.js';
    import { ImageCache } from './js/imageCache.js';
    import { FirebaseService } from './js/services/firebaseService.js';
    import { HistoryService } from './js/services/historyService.js';
    import { debounce, throttle, updateConnectionStatus as updateConnectionIndicator, showLoading, toast } from './js/utils.js';
    import { POINT_R, LINE_W, CONNECT_THRESH, CLICK_DETECT_RADIUS, DATA_COLLECTION_INTERVAL, DRAW_THROTTLE } from './js/constants.js';

    // ==================== GLOBAL STATE ====================
    let map, canvas, ctx;
    let currentLayer = null;
    let mapLayers = {};
    let tanks = [], valves = [], pipelines = [];
    let mode = 'pipeline';
    let isDrawing = false, currentPipeline = [];
    let hoveredDevice = null;
    let isFirebaseConnected = false;
    let flowCache = null;
    let flowCacheDirty = true;
    let lastDrawTime = 0;
    let dataCollectionInterval = null;
    let supplyDashboardCollapsed = false;
    let analyticsState = null;
    const STREAM_TARGET = 4;
    const scheduleDashboardRender =
      typeof window !== 'undefined' && typeof window.requestIdleCallback === 'function'
        ? (cb) => window.requestIdleCallback(cb, { timeout: 500 })
        : (cb) => {
            if (typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function') {
              window.requestAnimationFrame(cb);
            } else {
              setTimeout(cb, 16);
            }
          };
    let supplyDashboardUpdateScheduled = false;
    let liveDeviceRecords = {};
    let liveDeviceIndexExact = {};
    let liveDeviceIndexLower = {};
    let currentSidebarDeviceId = null;
    let currentSidebarDeviceType = null;

    function rebuildLiveDeviceIndex(devices = {}) {
      liveDeviceRecords = devices || {};
      liveDeviceIndexExact = {};
      liveDeviceIndexLower = {};
      Object.entries(liveDeviceRecords).forEach(([key, value]) => {
        const entryId = value?.id || key;
        if (!entryId) return;
        const normalizedId = String(entryId);
        const entry = { id: normalizedId, ...value };
        liveDeviceIndexExact[normalizedId] = entry;
        liveDeviceIndexLower[normalizedId.toLowerCase()] = entry;
      });
    }

    function findLiveDeviceTelemetryById(id) {
      if (!id) return null;
      const key = String(id);
      return liveDeviceIndexExact[key] || liveDeviceIndexLower[key.toLowerCase()] || null;
    }

    function resolveDeviceTelemetry(device, overrideId = null) {
      const candidates = [];
      if (overrideId) candidates.push(String(overrideId).toUpperCase().trim());
      if (device?.deviceId) candidates.push(String(device.deviceId).toUpperCase().trim());
      if (device?.id) candidates.push(String(device.id).toUpperCase().trim());
      for (const candidate of candidates) {
        const telemetry = findLiveDeviceTelemetryById(candidate);
        if (telemetry) return telemetry;
      }
      return null;
    }

    function refreshSidebarWithLiveTelemetry() {
      const sidebar = document.getElementById('sidebar');
      if (!sidebar || !sidebar.classList.contains('open')) return;
      if (!currentSidebarDeviceId || !currentSidebarDeviceType) return;
      const sourceList = currentSidebarDeviceType === 'tank' ? tanks : valves;
      const device = sourceList.find((item) => item.id === currentSidebarDeviceId);
      if (device) {
        showDevice(device, currentSidebarDeviceType);
      }
    }

    function updateConnectionStatus(connected) {
      isFirebaseConnected = connected;
      updateConnectionIndicator(connected);
    }

    // ==================== HOUSEHOLD SUPPLY CALCULATIONS ====================
    function calculateHouseholdStats() {
  if(analyticsState?.household) {
    const { stats = {}, regions = {}, valveTree = {} } = analyticsState.household;
    const mappedTree = new Map();
    Object.entries(valveTree).forEach(([id, node]) => mappedTree.set(id, node));
    return { stats, regions, valveTree: mappedTree };
  }

  const stats = { 
    totalHouseholds: 0, 
    servedHouseholds: 0, 
    mainValves: [],
    totalSupplyFlow: 0,
    averageSupplyPerHousehold: 0
  };

  // Build valve tree structure
  const valveTree = new Map();
  const mainValveIds = [];
  
  valves.forEach(valve => {
    valveTree.set(valve.id, {
      valve: valve,
      children: [],
      totalHouseholds: valve.households, // For main valve: this is the TOTAL capacity
      directHouseholds: valve.households, // Will be recalculated for main valves
      servedHouseholds: 0,
      totalFlow: 0
    });
    
    if(valve.category === 'main') {
      mainValveIds.push(valve.id);
    }
  });
  
  // Link children to parents and calculate direct households for main valves
  valves.forEach(valve => {
    if(valve.category === 'sub' && valve.parentValveId) {
      const parent = valveTree.get(valve.parentValveId);
      const child = valveTree.get(valve.id);
      if(parent && child) {
        parent.children.push(child);
      }
    }
  });
  
  // Calculate direct households for main valves
  // Direct = Total - Sum of all sub-valves
  mainValveIds.forEach(mainId => {
    const mainNode = valveTree.get(mainId);
    if(!mainNode) return;
    
    const subValvesTotal = mainNode.children.reduce((sum, child) => 
      sum + child.valve.households, 0);
    
    // Direct households = Total capacity - all sub-valves
    mainNode.directHouseholds = Math.max(0, mainNode.totalHouseholds - subValvesTotal);
  });
  
  // Calculate flow for each valve using BFS from tanks
  function calculateValveFlows() {
    const flow = computeFlow();
    
    valveTree.forEach(node => {
      if(!node.valve.active) {
        // Find pipelines connected to this valve
        const connectedPipelines = findAffectedPipelines(node.valve);
        
        // Sum up flow from connected pipelines that have active flow
        let totalFlow = 0;
        connectedPipelines.forEach(pipe => {
          if(pipe.currentFlow > 0) {
            totalFlow += pipe.currentFlow;
          }
        });
        
        node.totalFlow = totalFlow;
      } else {
        node.totalFlow = 0;
      }
    });
  }
  
  calculateValveFlows();
  
  // Calculate served households and distribute flow
  function calculateServedHouseholds(mainNode) {
    let served = 0;
    
    if(!mainNode.valve.active) {
      // Main valve is open
      
      // Count open sub-valves' households
      const openSubValves = mainNode.children.filter(c => !c.valve.active);
      const closedSubValves = mainNode.children.filter(c => c.valve.active);
      
      openSubValves.forEach(child => {
        served += child.valve.households;
        child.servedHouseholds = child.valve.households;
      });
      
      // Add main valve's direct households if any
      if(mainNode.directHouseholds > 0) {
        served += mainNode.directHouseholds;
      }
      
      // Distribute flow among open valves (sub + direct)
      if(mainNode.totalFlow > 0 && served > 0) {
        const totalOpenHouseholds = served;
        
        // Distribute to sub-valves
        openSubValves.forEach(child => {
          child.totalFlow = (child.valve.households / totalOpenHouseholds) * mainNode.totalFlow;
        });
        
        // Flow for main valve's direct households
        mainNode.directFlow = (mainNode.directHouseholds / totalOpenHouseholds) * mainNode.totalFlow;
      } else {
        mainNode.directFlow = 0;
      }
    } else {
      // Main valve is closed - nobody gets water
      served = 0;
      mainNode.children.forEach(child => {
        child.servedHouseholds = 0;
        child.totalFlow = 0;
      });
      mainNode.directFlow = 0;
    }
    
    mainNode.servedHouseholds = served;
    return served;
  }
  
  // Group by region (mandal)
  const regions = {};
  
  // Process main valves
  mainValveIds.forEach(mainId => {
    const mainNode = valveTree.get(mainId);
    if(!mainNode) return;
    
    const mainValve = mainNode.valve;
    
    // Calculate served households and flow distribution
    calculateServedHouseholds(mainNode);
    
    const mainValveData = {
      valve: mainValve,
      subValves: mainNode.children.map(c => c.valve),
      totalHouseholds: mainNode.totalHouseholds,
      directHouseholds: mainNode.directHouseholds,
      servedHouseholds: mainNode.servedHouseholds,
      totalFlow: mainNode.totalFlow,
      directFlow: mainNode.directFlow || 0,
      treeNode: mainNode
    };
    
    stats.mainValves.push(mainValveData);
    
    // Add to regions
    if(!regions[mainValve.mandal]) {
      regions[mainValve.mandal] = {
        name: mainValve.mandal,
        mainValves: [],
        totalHouseholds: 0,
        servedHouseholds: 0,
        totalFlow: 0
      };
    }
    regions[mainValve.mandal].mainValves.push(mainValveData);
  });
  
  // Calculate totals
  stats.mainValves.forEach(mainData => {
    stats.totalHouseholds += mainData.totalHouseholds;
    stats.servedHouseholds += mainData.servedHouseholds;
    stats.totalSupplyFlow += mainData.totalFlow;
  });
  
  // Calculate regional statistics
  Object.values(regions).forEach(region => {
    region.totalHouseholds = region.mainValves.reduce((sum, mv) => sum + mv.totalHouseholds, 0);
    region.servedHouseholds = region.mainValves.reduce((sum, mv) => sum + mv.servedHouseholds, 0);
    region.totalFlow = region.mainValves.reduce((sum, mv) => sum + mv.totalFlow, 0);
  });
  
  // Calculate average supply per household
  stats.averageSupplyPerHousehold = stats.servedHouseholds > 0 ? 
    stats.totalSupplyFlow / stats.servedHouseholds : 0;
  
  return { stats, regions, valveTree };
}





// ==================== TANK ETA CALCULATION ====================
function calculateTankETA(tank) {
  const serverEta = analyticsState?.tanks?.[tank.id]?.eta;
  if(serverEta) {
    return serverEta;
  }

  console.log('ðŸ” Calculating ETA for tank:', tank.name, 'Connected valves:', tank.connectedMainValves);
  
  // Check if tank has connected main valves configured
  if (!tank.connectedMainValves || tank.connectedMainValves.length === 0) {
    return {
      status: 'not_configured',
      message: 'No main valves connected to this tank',
      eta: null,
      flowRate: 0,
      details: []
    };
  }
  
  // Get ALL connected main valves (should be multiple)
  const connectedMainValves = valves.filter(v => 
    tank.connectedMainValves.includes(v.id) && v.category === 'main'
  );

  console.log('ðŸ“‹ Found connected main valves:', connectedMainValves.map(v => ({name: v.name, id: v.id, flowRate: v.flowRate, active: v.active})));

  if (connectedMainValves.length === 0) {
    return {
      status: 'not_configured',
      message: 'Connected main valves not found in system',
      eta: null,
      flowRate: 0,
      details: []
    };
  }

  // Calculate current water volume in liters
  // Calculate current water volume using accurate formula
  const currentVolume = tank.calculateCurrentVolume(); // Uses tank's actual dimensions
  // Calculate TOTAL flow from ALL connected main valves
  let totalCurrentFlow = 0;
  let totalPotentialFlow = 0;
  let totalHouseholdsServed = 0;
  let totalHouseholdsCapacity = 0;
  const valveDetails = [];

  // Process EACH connected main valve and its hierarchy
  connectedMainValves.forEach(mainValve => {
    console.log('ðŸ”§ Processing main valve:', mainValve.name, 'Flow rate:', mainValve.flowRate, 'Active:', mainValve.active);
    
    // Get ALL sub-valves for this main valve
    const subValves = valves.filter(v => 
      v.category === 'sub' && v.parentValveId === mainValve.id
    );

    console.log('   Sub-valves found:', subValves.length, subValves.map(sv => ({name: sv.name, flowRate: sv.flowRate, active: sv.active})));

    // Calculate flow for this main valve system
    let mainValveCurrentFlow = 0;
    let mainValvePotentialFlow = 0;
    let mainValveHouseholdsServed = 0;
    let mainValveHouseholdsCapacity = mainValve.households;

    if (!mainValve.active) {
      // Main valve is OPEN - calculate flow from entire system
      
      // 1. Main valve's own direct flow (if it serves direct households)
      if (mainValve.flowRate > 0) {
        mainValveCurrentFlow += mainValve.flowRate;
        mainValvePotentialFlow += mainValve.flowRate;
        mainValveHouseholdsServed += mainValve.households; // All households served when main valve open
      }
      
      // 2. Add flow from OPEN sub-valves
      const openSubValves = subValves.filter(v => !v.active);
      openSubValves.forEach(subValve => {
        mainValveCurrentFlow += subValve.flowRate || 0;
        mainValvePotentialFlow += subValve.flowRate || 0;
        mainValveHouseholdsServed += subValve.households || 0;
      });
      
      // 3. Add POTENTIAL flow from closed sub-valves
      const closedSubValves = subValves.filter(v => v.active);
      closedSubValves.forEach(subValve => {
        mainValvePotentialFlow += subValve.flowRate || 0;
        // Note: Households from closed sub-valves are NOT counted in current served
      });
      
    } else {
      // Main valve is CLOSED - no current flow, but calculate potential
      if (mainValve.flowRate > 0) {
        mainValvePotentialFlow += mainValve.flowRate;
      }
      subValves.forEach(subValve => {
        mainValvePotentialFlow += subValve.flowRate || 0;
      });
      // No households served when main valve is closed
    }

    // Add this main valve's contribution to totals
    totalCurrentFlow += mainValveCurrentFlow;
    totalPotentialFlow += mainValvePotentialFlow;
    totalHouseholdsServed += mainValveHouseholdsServed;
    totalHouseholdsCapacity += mainValveHouseholdsCapacity;

    valveDetails.push({
      id: mainValve.id,
      name: mainValve.name,
      isOpen: !mainValve.active,
      actualFlow: mainValveCurrentFlow,
      potentialFlow: mainValvePotentialFlow,
      openSubValves: subValves.filter(v => !v.active).length,
      totalSubValves: subValves.length,
      households: mainValveHouseholdsCapacity,
      householdsServed: mainValveHouseholdsServed,
      currentFlow: mainValveCurrentFlow,
      maxFlow: mainValvePotentialFlow,
      subValves: subValves.map(sv => ({
        name: sv.name,
        flowRate: sv.flowRate,
        active: sv.active,
        households: sv.households
      }))
    });
  });

  console.log('ðŸ“Š FINAL TOTALS - Current Flow:', totalCurrentFlow, 'Potential Flow:', totalPotentialFlow, 'Households Served:', totalHouseholdsServed);

  // Calculate ETAs using ACTUAL total flow from ALL valves
  let currentETA = null;
  let potentialETA = null;
  let currentTimeMinutes = 0;
  let potentialTimeMinutes = 0;

  if (totalCurrentFlow > 0) {
    currentTimeMinutes = currentVolume / totalCurrentFlow;
    const currentETATimestamp = Date.now() + (currentTimeMinutes * 60 * 1000);
    currentETA = new Date(currentETATimestamp);
  }

  if (totalPotentialFlow > 0) {
    potentialTimeMinutes = currentVolume / totalPotentialFlow;
    const potentialETATimestamp = Date.now() + (potentialTimeMinutes * 60 * 1000);
    potentialETA = new Date(potentialETATimestamp);
  }

  // Format time display properly
  const formatTime = (minutes) => {
    if (minutes === Infinity || isNaN(minutes) || !isFinite(minutes)) return 'Infinite';
    
    const totalMinutes = Math.max(0, minutes);
    const days = Math.floor(totalMinutes / (60 * 24));
    const remainingHours = Math.floor((totalMinutes % (60 * 24)) / 60);
    const remainingMinutes = Math.floor(totalMinutes % 60);
    
    if (days > 0) {
      return `${days}d ${remainingHours}h ${remainingMinutes}m`;
    } else if (remainingHours > 0) {
      return `${remainingHours}h ${remainingMinutes}m`;
    } else {
      return `${remainingMinutes}m`;
    }
  };

  // Determine status based on current flow and time
  let status = 'good';
  let statusColor = '#4caf50';
  let statusMessage = 'Supply is stable';
  
  if (totalCurrentFlow === 0) {
    status = 'no_flow';
    statusColor = '#999';
    statusMessage = 'No water flowing - all valves closed';
  } else if (currentTimeMinutes < 60) { // 1 hour
    status = 'critical';
    statusColor = '#f44336';
    statusMessage = 'CRITICAL: Tank will be empty soon!';
  } else if (currentTimeMinutes < 240) { // 4 hours
    status = 'warning';
    statusColor = '#ff9800';
    statusMessage = 'Warning: Low water level';
  }

  console.log('â° ETA Calculation Complete:', {
    status,
    currentTimeMinutes,
    currentTimeFormatted: formatTime(currentTimeMinutes),
    totalCurrentFlow,
    currentVolume
  });

  return {
    status,
    statusColor,
    statusMessage,
    currentFlow: totalCurrentFlow,
    potentialFlow: totalPotentialFlow,
    currentVolume: Math.round(currentVolume),
    tankCapacity: tank.capacity,
    waterLevel: tank.waterLevel,
    currentETA: currentETA,
    currentETAFormatted: currentETA ? currentETA.toLocaleString() : 'N/A',
    currentTimeMinutes: Math.round(currentTimeMinutes * 10) / 10, // 1 decimal place
    currentTimeFormatted: totalCurrentFlow > 0 ? formatTime(currentTimeMinutes) : 'Infinite',
    potentialETA: potentialETA,
    potentialETAFormatted: potentialETA ? potentialETA.toLocaleString() : 'N/A',
    potentialTimeMinutes: Math.round(potentialTimeMinutes * 10) / 10,
    potentialTimeFormatted: totalPotentialFlow > 0 ? formatTime(potentialTimeMinutes) : 'Infinite',
    connectedMainValves: connectedMainValves.length,
    openMainValves: connectedMainValves.filter(v => !v.active).length,
    totalHouseholdsServed: totalHouseholdsServed,
    totalHouseholdsCapacity: totalHouseholdsCapacity,
    valveDetails: valveDetails,
    calculationDetails: {
      tankHeight: tankHeight,
      currentVolume: currentVolume,
      totalCurrentFlow: totalCurrentFlow,
      totalPotentialFlow: totalPotentialFlow,
      connectedValvesCount: connectedMainValves.length
    }
  };
}







function calculatePipelineCapacity(diameterMM) {
  // Basic formula: Flow capacity in L/min based on pipe diameter
  // Using simplified hydraulic formula: Q = Ï€ * (d/2)^2 * v
  // Where d is diameter in meters, v is velocity in m/s (assuming 1.5 m/s typical velocity)
  const diameterM = diameterMM / 1000;
  const crossSectionArea = Math.PI * Math.pow(diameterM / 2, 2);
  const velocity = 1.5; // 1.5 m/s typical water velocity
  const flowRateM3s = crossSectionArea * velocity;
  const flowRateLmin = flowRateM3s * 1000 * 60; // Convert to L/min
  
  return Math.round(flowRateLmin);
}


// Add this event listener after your existing initUI code
const diameterInput = document.getElementById('pipelineDiameter');
if (diameterInput) {
  diameterInput.addEventListener('change', (e) => {
    const diameter = parseFloat(e.target.value);
    if (!isNaN(diameter) && diameter > 0) {
      const capacity = calculatePipelineCapacity(diameter);
      document.getElementById('pipelineCapacity').value = capacity;
    }
  });
}

    function calculateSupplyPerHousehold() {
  if(analyticsState?.household?.supplies) {
    return analyticsState.household.supplies;
  }

  const supplies = [];
  const { stats, valveTree } = calculateHouseholdStats();

  // Process each main valve and its children
  stats.mainValves.forEach(mainData => {
    const mainNode = mainData.treeNode;
    
    if(!mainData.valve.active && mainData.totalFlow > 0) {
      // Add supply info for each open sub-valve
      mainData.subValves.forEach(subValve => {
        const subNode = valveTree.get(subValve.id);
        if(!subNode) return;
        
        if(!subValve.active && subValve.households > 0) {
          const avgSupply = subNode.totalFlow > 0 ? 
            subNode.totalFlow / subValve.households : 0;
          
          supplies.push({
            valveId: subValve.id,
            valveName: subValve.name,
            households: subValve.households,
            totalFlow: subNode.totalFlow,
            avgSupply: avgSupply,
            mandal: subValve.mandal,
            habitation: subValve.habitation,
            parentValve: mainData.valve.name,
            type: 'sub'
          });
        }
      });
      
      // Add main valve's direct households if any
      if(mainNode.directHouseholds > 0) {
        const avgSupply = mainNode.directFlow > 0 ? 
          mainNode.directFlow / mainNode.directHouseholds : 0;
        
        supplies.push({
          valveId: mainData.valve.id,
          valveName: `${mainData.valve.name} (Direct)`,
          households: mainNode.directHouseholds,
          totalFlow: mainNode.directFlow,
          avgSupply: avgSupply,
          mandal: mainData.valve.mandal,
          habitation: mainData.valve.habitation,
          parentValve: 'Main Line',
          type: 'main-direct'
        });
      }
    }
  });

  return supplies;
}

    // ==================== SUPPLY DASHBOARD ====================
    // ==================== SUPPLY DASHBOARD WITH REGIONAL FILTER ====================
let currentRegionFilter = null; // null means show all regions

function requestSupplyDashboardUpdate() {
  if (supplyDashboardUpdateScheduled) return;
  supplyDashboardUpdateScheduled = true;
  scheduleDashboardRender(() => {
    supplyDashboardUpdateScheduled = false;
    try {
      updateSupplyDashboard();
    } catch (error) {
      console.error('Supply dashboard render failed', error);
    }
  });
}

function updateSupplyDashboard() {
  const { stats, regions, valveTree } = calculateHouseholdStats();
  const supplies = calculateSupplyPerHousehold();
  
  const dashboardBody = document.getElementById('supplyDashboardBody');
  
  if (Object.keys(regions).length === 0) {
    dashboardBody.innerHTML = `
      <div style="text-align: center; padding: 20px; color: var(--muted);">
        <i class="fas fa-tachometer-alt" style="font-size: 24px; margin-bottom: 8px;"></i>
        <div>No supply data available</div>
      </div>
    `;
    return;
  }
  
  let html = '';
  
  // Add region filter dropdown
  const regionNames = Object.keys(regions);
  if (regionNames.length > 1) {
    html += `
      <div style="margin-bottom: 12px; padding: 12px; background: #f8f9fa; border-radius: 8px;">
        <label style="font-size: 12px; font-weight: 600; color: var(--muted); display: block; margin-bottom: 6px;">
          <i class="fas fa-filter"></i> FILTER BY REGION
        </label>
        <select id="regionFilterSelect" style="width: 100%; padding: 8px; border: 1px solid var(--line); border-radius: 6px; font-size: 13px;">
          <option value="">All Regions</option>
          ${regionNames.map(name => `
            <option value="${name}" ${currentRegionFilter === name ? 'selected' : ''}>${name}</option>
          `).join('')}
        </select>
      </div>
    `;
  }
  
  // Filter regions based on selection
  const filteredRegions = currentRegionFilter 
    ? { [currentRegionFilter]: regions[currentRegionFilter] }
    : regions;
  
  // Calculate filtered totals
  const filteredStats = {
    totalHouseholds: 0,
    servedHouseholds: 0,
    totalSupplyFlow: 0
  };
  
  Object.values(filteredRegions).forEach(region => {
    filteredStats.totalHouseholds += region.totalHouseholds;
    filteredStats.servedHouseholds += region.servedHouseholds;
    filteredStats.totalSupplyFlow += region.totalFlow;
  });
  
  filteredStats.averageSupplyPerHousehold = filteredStats.servedHouseholds > 0 
    ? filteredStats.totalSupplyFlow / filteredStats.servedHouseholds 
    : 0;
  
  // Add summary section with filtered data
  html += `
    <div class="supply-summary">
      ${currentRegionFilter ? `
        <div style="background: rgba(255,255,255,0.15); padding: 8px; border-radius: 6px; margin-bottom: 12px; text-align: center;">
          <div style="font-size: 11px; opacity: 0.8;">SHOWING DATA FOR</div>
          <div style="font-size: 14px; font-weight: 700;">${currentRegionFilter}</div>
        </div>
      ` : ''}
      <div class="supply-summary-row">
        <span class="supply-summary-label">Total Households</span>
        <span class="supply-summary-value">${filteredStats.totalHouseholds}</span>
      </div>
      <div class="supply-summary-row">
        <span class="supply-summary-label">Served Households</span>
        <span class="supply-summary-value">${filteredStats.servedHouseholds}</span>
      </div>
      <div class="supply-summary-row">
        <span class="supply-summary-label">Coverage</span>
        <span class="supply-summary-value">${filteredStats.totalHouseholds > 0 ? ((filteredStats.servedHouseholds / filteredStats.totalHouseholds) * 100).toFixed(1) : 0}%</span>
      </div>
      <div class="supply-summary-row">
        <span class="supply-summary-label">Total Flow</span>
        <span class="supply-summary-value">${filteredStats.totalSupplyFlow.toFixed(0)} L/min</span>
      </div>
      <div class="supply-summary-row">
        <span class="supply-summary-label">Avg Supply/HH</span>
        <span class="supply-summary-value">${filteredStats.averageSupplyPerHousehold.toFixed(1)} L/min</span>
      </div>
    </div>
  `;
  
  // Add regions
  Object.values(filteredRegions).forEach(region => {
    if (region.mainValves.length > 0) {
      html += `
        <div class="supply-region">
          <div class="supply-region-header">
            <div class="supply-region-name">${region.name}</div>
            <div class="supply-region-stats">
              <span>${region.servedHouseholds}/${region.totalHouseholds} HH</span>
              <span>${region.totalFlow.toFixed(0)} L/min</span>
            </div>
          </div>
          <div class="supply-region-body">
      `;
      
      region.mainValves.forEach(mainValveData => {
        const mainValve = mainValveData.valve;
        const mainNode = mainValveData.treeNode;
        
        html += `
          <div class="supply-valve">
            <div class="supply-valve-info">
              <div class="supply-valve-name">${mainValve.name} (Main)</div>
              <div class="supply-valve-meta">
                Total: ${mainValveData.totalHouseholds} HH 
                ${mainNode.directHouseholds > 0 ? `â€¢ Direct: ${mainNode.directHouseholds} HH` : ''}
                â€¢ Served: ${mainValveData.servedHouseholds}/${mainValveData.totalHouseholds}
              </div>
            </div>
            <div>
              <span class="supply-valve-status ${mainValve.active ? 'closed' : 'open'}">
                ${mainValve.active ? 'CLOSED' : 'OPEN'}
              </span>
              <div class="supply-valve-flow">${mainValveData.totalFlow.toFixed(0)} L/min</div>
            </div>
          </div>
        `;
        
        if(mainNode.directHouseholds > 0 && !mainValve.active) {
          const directSupply = supplies.find(s => s.valveId === mainValve.id && s.type === 'main-direct');
          const directFlow = mainNode.directFlow || 0;
          const avgSupply = directSupply ? directSupply.avgSupply : 0;
          
          html += `
            <div class="supply-valve" style="margin-left: 12px; background: #f0f7ff;">
              <div class="supply-valve-info">
                <div class="supply-valve-name">â†³ Direct Connection</div>
                <div class="supply-valve-meta">
                  ${mainNode.directHouseholds} HH â€¢ ${avgSupply.toFixed(2)} L/min/HH
                </div>
              </div>
              <div>
                <div class="supply-valve-flow">${directFlow.toFixed(0)} L/min</div>
              </div>
            </div>
          `;
        }
        
        mainValveData.subValves.forEach(subValve => {
          const subNode = valveTree.get(subValve.id);
          const subValveSupply = supplies.find(s => s.valveId === subValve.id);
          const flow = subValveSupply ? subValveSupply.totalFlow : 0;
          const avgSupply = subValveSupply ? subValveSupply.avgSupply : 0;
          
          html += `
            <div class="supply-valve" style="margin-left: 12px;">
              <div class="supply-valve-info">
                <div class="supply-valve-name">â†³ ${subValve.name}</div>
                <div class="supply-valve-meta">
                  ${subValve.households} HH â€¢ ${avgSupply.toFixed(2)} L/min/HH â€¢ ${subValve.habitation}
                </div>
              </div>
              <div>
                <span class="supply-valve-status ${subValve.active ? 'closed' : 'open'}">
                  ${subValve.active ? 'CLOSED' : 'OPEN'}
                </span>
                <div class="supply-valve-flow">${flow.toFixed(0)} L/min</div>
              </div>
            </div>
          `;
        });
      });
      
      html += `</div></div>`;
    }
  });
  
  dashboardBody.innerHTML = html;
  
  // Add event listener for region filter
  const filterSelect = document.getElementById('regionFilterSelect');
  if (filterSelect) {
    filterSelect.addEventListener('change', (e) => {
      currentRegionFilter = e.target.value || null;
      requestSupplyDashboardUpdate();
      toast(currentRegionFilter ? `ðŸ“ Filtered: ${currentRegionFilter}` : 'ðŸŒ Showing all regions');
    });
  }
}

// Auto-filter dashboard when viewing a device
function autoFilterDashboardByDevice(device) {
  const regionKey = device.mandal || (device.state ? `${device.state}-${device.district}` : null);
  if (regionKey) {
    currentRegionFilter = regionKey;
    requestSupplyDashboardUpdate();
  }
}

    function toggleSupplyDashboard() {
      const dashboard = document.getElementById('supplyDashboard');
      const body = document.getElementById('supplyDashboardBody');
      const toggleBtn = document.getElementById('toggleSupplyDashboard');
      
      if (supplyDashboardCollapsed) {
        body.style.display = 'block';
        toggleBtn.innerHTML = '<i class="fas fa-chevron-down"></i>';
        supplyDashboardCollapsed = false;
      } else {
        body.style.display = 'none';
        toggleBtn.innerHTML = '<i class="fas fa-chevron-up"></i>';
        supplyDashboardCollapsed = true;
      }
    }

    // ==================== INITIALIZATION ====================
    let isInitialized = false;
    let loadedCount = 0;
    
    async function initializeWaterApp() {
      if(isInitialized) return;
      isInitialized = true;
      
      showLoading(true);
      updateConnectionStatus(false);
      
      try {
        await ImageCache.preload();
        
        // Wait for Leaflet to be fully loaded
        if(typeof L === 'undefined') {
          console.error('Leaflet not loaded yet');
          setTimeout(initializeWaterApp, 100);
          return;
        }
        
        initMap();
        initCanvas();
        initUI();
        
        const checkAllLoaded = () => {
          loadedCount++;
          if(loadedCount >= STREAM_TARGET) {
            updateConnectionStatus(true);
            showLoading(false);
            if(tanks.length === 0 && valves.length === 0 && pipelines.length === 0) {
              setTimeout(initializeDummyData, 500);
            }
          }
        };
        
        FirebaseService.listenToTanks((loadedTanks) => {
          tanks = loadedTanks;
          flowCacheDirty = true;
          if(loadedCount < STREAM_TARGET) checkAllLoaded();
          requestDrawCanvas();
          requestSupplyDashboardUpdate();
        });
        
        FirebaseService.listenToValves((loadedValves) => {
          valves = loadedValves;
          flowCacheDirty = true;
          if(loadedCount < STREAM_TARGET) checkAllLoaded();
          requestDrawCanvas();
          requestSupplyDashboardUpdate();
        });
        
        FirebaseService.listenToPipelines((loadedPipelines) => {
          pipelines = loadedPipelines;
          flowCacheDirty = true;
          if(loadedCount < STREAM_TARGET) checkAllLoaded();
          requestDrawCanvas();
          requestSupplyDashboardUpdate();
        });

        FirebaseService.listenToAnalytics((analytics) => {
          analyticsState = analytics;
          flowCacheDirty = true;
          if(loadedCount < STREAM_TARGET) checkAllLoaded();
          requestDrawCanvas();
          requestSupplyDashboardUpdate();
        });

        FirebaseService.listenToDevices(async (devices) => {
          rebuildLiveDeviceIndex(devices);
          if(loadedCount < STREAM_TARGET) checkAllLoaded();
          refreshSidebarWithLiveTelemetry();
          
          // Sync all device readings to history (automatic sync on data update)
          if (FirebaseService.lastDeviceRawData) {
            const skipPaths = ['tanks', 'valves', 'pipelines', 'analytics', 'ultrasonic', 'history'];
            const rawData = FirebaseService.lastDeviceRawData;
            
            // Process root-level device nodes
            for (const deviceId of Object.keys(rawData)) {
              if (skipPaths.includes(deviceId)) continue;
              
              const deviceNode = rawData[deviceId];
              if (!deviceNode || typeof deviceNode !== 'object') continue;
              
              // Extract all readings from this device
              const allReadings = FirebaseService.extractAllReadings(deviceNode);
              
              if (allReadings.length > 0) {
                // Find which tank is linked to this device
                const linkedTank = tanks.find(t => t.deviceId && t.deviceId.toUpperCase() === deviceId.toUpperCase());
                if (linkedTank) {
                  // Sync all readings to history with tank for calculations
                  await HistoryService.syncDeviceReadingsToHistory(linkedTank.id, 'tanks', allReadings, linkedTank);
                }
              }
            }
            
            // Also check /ultrasonic path
            if (rawData.ultrasonic && typeof rawData.ultrasonic === 'object') {
              for (const deviceId of Object.keys(rawData.ultrasonic)) {
                const deviceNode = rawData.ultrasonic[deviceId];
                const allReadings = FirebaseService.extractAllReadings(deviceNode);
                
                if (allReadings.length > 0) {
                  const linkedTank = tanks.find(t => t.deviceId && t.deviceId.toUpperCase() === deviceId.toUpperCase());
                  if (linkedTank) {
                    await HistoryService.syncDeviceReadingsToHistory(linkedTank.id, 'tanks', allReadings, linkedTank);
                  }
                }
              }
            }
          }
          
          // Update tanks with real water levels from devices
          tanks.forEach(tank => {
            if (tank.deviceId) {
              const telemetry = resolveDeviceTelemetry(tank);
              if (telemetry && telemetry.distance !== undefined && telemetry.distance !== null) {
                const newWaterLevel = tank.calculateWaterLevelFromDistance(telemetry.distance);
                if (Math.abs(tank.waterLevel - newWaterLevel) > 0.01) {
                  tank.setWaterLevel(newWaterLevel);
                  flowCacheDirty = true;
                }
              }
            }
          });
          if (flowCacheDirty) {
            requestDrawCanvas();
            requestSupplyDashboardUpdate();
          }
        });
        
        setTimeout(() => {
          if(loadedCount < STREAM_TARGET) {
            console.warn('Firebase loading timeout');
            updateConnectionStatus(false);
            showLoading(false);
          }
        }, 5000);
        
        // Automatically sync all device data to history after initial load
        setTimeout(async () => {
          console.log('ðŸ”„ Auto-syncing device data to history...');
          try {
            // Fetch all device data directly from Firebase
            const allDeviceData = await FirebaseService.fetchAllDeviceData();
            
            if (Object.keys(allDeviceData).length === 0) {
              console.log('ðŸ“­ No device data found for auto-sync');
              return;
            }
            
            const skipPaths = ['tanks', 'valves', 'pipelines', 'analytics', 'ultrasonic', 'history'];
            let totalSynced = 0;
            
            // Process each device
            for (const deviceId of Object.keys(allDeviceData)) {
              if (skipPaths.includes(deviceId)) continue;
              
              const deviceNode = allDeviceData[deviceId];
              if (!deviceNode || typeof deviceNode !== 'object') continue;
              
              // Extract all readings from this device
              const allReadings = FirebaseService.extractAllReadings(deviceNode);
              
              if (allReadings.length > 0) {
                // Find which tank is linked to this device
                const linkedTank = tanks.find(t => t.deviceId && t.deviceId.toUpperCase() === deviceId.toUpperCase());
                
                if (linkedTank) {
                  console.log(`ðŸ”„ Auto-syncing ${allReadings.length} readings for device ${deviceId} â†’ tank ${linkedTank.id}`);
                  // Sync with tank object for calculations
                  await HistoryService.syncDeviceReadingsToHistory(linkedTank.id, 'tanks', allReadings, linkedTank);
                  totalSynced += allReadings.length;
                }
              }
            }
            
            if (totalSynced > 0) {
              console.log(`âœ… Auto-sync complete! Synced ${totalSynced} readings to history.`);
            }
          } catch (error) {
            console.error('âŒ Error in auto-sync:', error);
          }
        }, 3000); // Wait 3 seconds after initial load to ensure tanks are loaded
        
      } catch(error) {
        console.error('Initialization error:', error);
        showLoading(false);
        toast('âš ï¸ Initialization error');
      }
    }

    async function initializeDummyData() {
      toast('ðŸ“¦ Creating sample data...');
      
      // Create multiple tanks in different regions
      const dummyTanks = [
        {
          id: 'TANK-MAIN-001',
          name: 'Main Distribution Tank',
          lat: 17.9689,
          lng: 79.5941,
          type: 'OHSR',
          capacity: 50000,
          waterLevel: 8.5,
          state: 'Telangana',
          district: 'Mulugu',
          mandal: 'Eturunagaram',
          habitation: 'Central Area'
        },
        {
          id: 'TANK-SEC-001',
          name: 'Secondary Tank - Zone B',
          lat: 17.9750,
          lng: 79.6000,
          type: 'GSR',
          capacity: 30000,
          waterLevel: 7.2,
          state: 'Telangana',
          district: 'Mulugu',
          mandal: 'Venkatapur',
          habitation: 'Zone B Central'
        }
      ];
      
      for(const tankData of dummyTanks) {
        const tank = new Tank(tankData);
        await FirebaseService.saveTank(tank);
      }
      
      // Create main valves for different regions
      const mainValves = [
        {
          id: 'VALVE-MAIN-001',
          name: 'Main Gate Valve - Eturunagaram',
          lat: 17.9700,
          lng: 79.5950,
          type: 'STRAIGHT',
          category: 'main',
          households: 40,
          mandal: 'Eturunagaram',
          habitation: 'Distribution Zone'
        },
        {
          id: 'VALVE-MAIN-002',
          name: 'Main Gate Valve - Venkatapur',
          lat: 17.9760,
          lng: 79.6010,
          type: 'STRAIGHT',
          category: 'main',
          households: 35,
          mandal: 'Venkatapur',
          habitation: 'Distribution Zone'
        }
      ];
      
      for(const valveData of mainValves) {
        const valve = new Valve(valveData);
        await FirebaseService.saveValve(valve);
      }
      
      // Create sub-valves for different regions
      const subValves = [
        {id: 'VALVE-SUB-001', name: 'Sub Valve - Zone A', lat: 17.9710, lng: 79.5960, habitation: 'Zone A', mandal: 'Eturunagaram', parentValveId: 'VALVE-MAIN-001', households: 12},
        {id: 'VALVE-SUB-002', name: 'Sub Valve - Zone B', lat: 17.9715, lng: 79.5965, habitation: 'Zone B', mandal: 'Eturunagaram', parentValveId: 'VALVE-MAIN-001', households: 14},
        {id: 'VALVE-SUB-003', name: 'Sub Valve - Zone C', lat: 17.9720, lng: 79.5970, habitation: 'Zone C', mandal: 'Eturunagaram', parentValveId: 'VALVE-MAIN-001', households: 14},
        {id: 'VALVE-SUB-004', name: 'Sub Valve - North Area', lat: 17.9770, lng: 79.6020, habitation: 'North Area', mandal: 'Venkatapur', parentValveId: 'VALVE-MAIN-002', households: 18},
        {id: 'VALVE-SUB-005', name: 'Sub Valve - South Area', lat: 17.9755, lng: 79.6005, habitation: 'South Area', mandal: 'Venkatapur', parentValveId: 'VALVE-MAIN-002', households: 17}
      ];
      
      for(const sv of subValves) {
        await FirebaseService.saveValve(new Valve({
          ...sv,
          type: 'STRAIGHT',
          category: 'sub'
        }));
      }
      
      // Create pipelines connecting tanks to valves
      const pipeline1 = new Pipeline({
        id: 'PIPE-MAIN-001',
        name: 'Main Supply Line - Eturunagaram',
        type: 'PVC',
        diameter: 200,
        capacity: 800,
        startPoint: 'Main Tank',
        endPoint: 'Main Valve',
        points: [
          {lat: 17.9689, lng: 79.5941},
          {lat: 17.9695, lng: 79.5945},
          {lat: 17.9700, lng: 79.5950}
        ]
      });
      await FirebaseService.savePipeline(pipeline1);
      
      const pipeline2 = new Pipeline({
        id: 'PIPE-DIST-001',
        name: 'Distribution Line - Zone A',
        type: 'PVC',
        diameter: 150,
        capacity: 500,
        startPoint: 'Main Valve',
        endPoint: 'Zone A',
        points: [
          {lat: 17.9700, lng: 79.5950},
          {lat: 17.9705, lng: 79.5955},
          {lat: 17.9710, lng: 79.5960}
        ]
      });
      await FirebaseService.savePipeline(pipeline2);
      
      const pipeline3 = new Pipeline({
        id: 'PIPE-MAIN-002',
        name: 'Main Supply Line - Venkatapur',
        type: 'HDPE',
        diameter: 180,
        capacity: 700,
        startPoint: 'Secondary Tank',
        endPoint: 'Venkatapur Main Valve',
        points: [
          {lat: 17.9750, lng: 79.6000},
          {lat: 17.9755, lng: 79.6005},
          {lat: 17.9760, lng: 79.6010}
        ]
      });
      await FirebaseService.savePipeline(pipeline3);
      
      toast('âœ“ Sample data created!');
    }

    document.addEventListener('DOMContentLoaded', initializeWaterApp);

    function initMap() {
      try {
        map = L.map('map', {
          zoomControl: false,
          minZoom: 2,
          maxZoom: 19,
          preferCanvas: true,
          zoomAnimation: true,
          fadeAnimation: true
        }).setView([17.9689, 79.5941], 13);

        // Define map layers
        // Define map layers with multiple backup options
      // Define map layers - Best quality options
      mapLayers = {
        street: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 19,
          attribution: 'Â© OpenStreetMap'
        }),
        
        satellite: L.tileLayer('http://mt{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
          maxZoom: 20,
          subdomains: ['0','1','2','3'],
          attribution: 'Â© Google'
        }),
        
        dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
          maxZoom: 19,
          subdomains: 'abcd',
          attribution: 'Â© CARTO'
        })
      };

        // Add default layer with error handling
        currentLayer = mapLayers.street;
        currentLayer.addTo(map);
        
        // Add error handler for tile loading
        currentLayer.on('tileerror', function(error) {
          console.warn('Tile loading error:', error);
        });

        const debouncedDraw = debounce(requestDrawCanvas, 100);
        map.on('move', debouncedDraw);
        map.on('zoom', debouncedDraw);
        map.on('moveend', requestDrawCanvas);
        map.on('zoomend', requestDrawCanvas);
        map.on('contextmenu', onMapRightClick);
        map.on('click', onMapClick);
        
        console.log('Map initialized successfully');
      } catch(error) {
        console.error('Error initializing map:', error);
        toast('âš ï¸ Map initialization failed');
      }
    }



    function switchMapLayer(layerName) {
      if(!mapLayers[layerName]) {
        console.error('Layer not available:', layerName);
        toast('âš ï¸ Map layer not available');
        return;
      }
      
      if(currentLayer) {
        try {
          map.removeLayer(currentLayer);
        } catch(e) {
          console.error('Error removing layer:', e);
        }
      }
      
      currentLayer = mapLayers[layerName];
      
      try {
        currentLayer.addTo(map);
      } catch(e) {
        console.error('Error adding layer:', e);
        toast('âš ï¸ Failed to load map layer');
        return;
      }
      
      document.querySelectorAll('.layer').forEach(btn => btn.classList.remove('active'));
      document.getElementById(`layer${layerName.charAt(0).toUpperCase() + layerName.slice(1)}`).classList.add('active');
      
      toast(`âœ“ ${layerName.charAt(0).toUpperCase() + layerName.slice(1)} view`);
      requestDrawCanvas();
    }

    function initCanvas() {
      canvas = document.getElementById('canvas');
      ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });
      resizeCanvas();
      window.addEventListener('resize', debounce(resizeCanvas, 250));

      canvas.addEventListener('mousedown', handleCanvasMouseDown);
      canvas.addEventListener('mousemove', throttle(handleCanvasMouseMove, 16));
      canvas.addEventListener('mouseup', handleCanvasMouseUp);
      canvas.addEventListener('mouseleave', handleCanvasMouseUp);
    }

    function resizeCanvas() {
      const rect = map.getContainer().getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      requestDrawCanvas();
    }

    function initUI() {
      // Tool buttons
      bindBtn('toolPipeline', () => setMode('pipeline'));
      bindBtn('toolTank', () => setMode('tank'));
      bindBtn('toolValve', () => setMode('valve'));
      bindBtn('toolErase', () => setMode('erase'));
      bindBtn('toolManage', openManage);
      bindBtn('toolImport', () => {
        const importFile = document.getElementById('importFile');
        if(importFile) importFile.click();
      });
      bindBtn('toolClear', clearAll);
      bindBtn('layerStreet', () => {
        if(!map || !mapLayers.street) {
          toast('âš ï¸ Map not ready yet');
          return;
        }
        switchMapLayer('street');
      });
      
      bindBtn('layerSatellite', () => {
        if(!map || !mapLayers.satellite) {
          toast('âš ï¸ Map not ready yet');
          return;
        }
        switchMapLayer('satellite');
      });
      
      bindBtn('layerDark', () => {
        if(!map || !mapLayers.dark) {
          toast('âš ï¸ Map not ready yet');
          return;
        }
        switchMapLayer('dark');
      });
      bindBtn('zoomIn', () => map.zoomIn());
      bindBtn('zoomOut', () => map.zoomOut());
      bindBtn('closeSidebar', closeSidebar);
      bindBtn('toggleSupplyDashboard', toggleSupplyDashboard);

      // Modal close buttons
      document.querySelectorAll('[data-close]').forEach(btn => {
        btn.addEventListener('click', () => closeModal(btn.getAttribute('data-close')));
      });
 
      
      // Save buttons
      bindBtn('saveTank', onSaveTank);


      


     // Tank shape toggle
const tankShape = document.getElementById('tankShape');
if(tankShape) {
  tankShape.addEventListener('change', (e) => {
    const cylinderDiv = document.getElementById('cylinderDimensions');
    const cuboidDiv = document.getElementById('cuboidDimensions');
    const isCylinder = e.target.value === 'cylinder';
    
    if(cylinderDiv) cylinderDiv.style.display = isCylinder ? 'block' : 'none';
    if(cuboidDiv) cuboidDiv.style.display = isCylinder ? 'none' : 'block';
  });
}

// Auto-calculate capacity
bindBtn('calculateCapacity', () => {
  const shape = val('tankShape');
  let capacity = 0;
  
  if(shape === 'cylinder') {
    const diameter = parseFloat(val('tankDiameter'));
    const height = parseFloat(val('tankHeight'));
    if(!isNaN(diameter) && !isNaN(height)) {
      const radius = diameter / 2;
      capacity = Math.PI * Math.pow(radius, 2) * height * 1000; // mÂ³ to liters
    }
  } else if(shape === 'cuboid') {
    const length = parseFloat(val('tankLength'));
    const breadth = parseFloat(val('tankBreadth'));
    const height = parseFloat(val('tankHeightCuboid'));
    if(!isNaN(length) && !isNaN(breadth) && !isNaN(height)) {
      capacity = length * breadth * height * 1000; // mÂ³ to liters
    }
  }
  
  if(capacity > 0) {
    setValue('tankCapacity', Math.round(capacity));
    toast(`âœ“ Capacity calculated: ${Math.round(capacity).toLocaleString()} L`);
  } else {
    toast('âš ï¸ Enter valid dimensions');
  }
});







      bindBtn('saveValve', onSaveValve);
      bindBtn('savePipeline', onSavePipeline);

      // Pipeline delete from modal
      const deletePipelineBtn = document.getElementById('deleteThisPipeline');
      if(deletePipelineBtn) {
        deletePipelineBtn.addEventListener('click', () => {
          const pipeId = document.getElementById('pipelineModal').getAttribute('data-pipe-id');
          if(pipeId) deletePipeline(pipeId);
        });
      }

      // Manage modal tabs
      const manageModal = document.getElementById('manageModal');
      if(manageModal) {
        manageModal.addEventListener('click', (e) => {
          const tab = e.target.closest('[data-tab]');
          if (tab) {
            document.querySelectorAll('#manageModal [data-tab]').forEach(b => b.classList.remove('primary'));
            tab.classList.add('primary');
            renderManage(tab.getAttribute('data-tab'));
          }
        });
      }

      // Import file
      const importFile = document.getElementById('importFile');
      if(importFile) {
        importFile.addEventListener('change', importData);
      }
      
      // Valve category change
      const valveCategory = document.getElementById('valveCategory');
      if(valveCategory) {
        valveCategory.addEventListener('change', (e) => {
          const parentRow = document.getElementById('parentValveRow');
          if(parentRow) {
            if(e.target.value === 'sub') {
              parentRow.style.display = 'block';
              updateParentValveList();
            } else {
              parentRow.style.display = 'none';
            }
          }
        });
      }

      // Search functionality
      const searchInput = document.getElementById('searchInput');
      const searchBtn = document.getElementById('searchBtn');
      
      if(searchInput) {
        searchInput.addEventListener('input', debounce(onSearchInput, 400));
        searchInput.addEventListener('keydown', (e) => {
          if(e.key === 'Enter') { e.preventDefault(); executeSearch(); }
          if(e.key === 'Escape') { hideSuggestions(); }
        });
      }
      if(searchBtn) searchBtn.addEventListener('click', executeSearch);
      
      // History modal
      bindBtn('filterHistoryBtn', loadHistory);
      bindBtn('exportHistoryBtn', exportCurrentHistory);
      // Click outside to close suggestions
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.search')) hideSuggestions();
      });

      updateToolbar();
    }

    function updateParentValveList() {
      const select = document.getElementById('parentValve');
      const mainValves = valves.filter(v => v.category === 'main');
      select.innerHTML = '<option value="">None</option>';
      mainValves.forEach(valve => {
        const option = document.createElement('option');
        option.value = valve.id;
        option.textContent = `${valve.name} (${valve.id})`;
        select.appendChild(option);
      });
    }



   function populateMainValvesList(selectedValves = []) {
  const container = document.getElementById('mainValvesList');
  const mainValves = valves.filter(v => v.category === 'main');
  
  if (mainValves.length === 0) {
    container.innerHTML = `
      <div style="text-align: center; color: var(--muted); padding: 20px;">
        <i class="fas fa-exclamation-circle"></i> No main valves available<br>
        <small>Create main valves first before connecting them to tanks</small>
      </div>
    `;
    return;
  }
  
  // Currently selected valves display
  const selectedValvesDisplay = selectedValves.map(valveId => {
    const valve = mainValves.find(v => v.id === valveId);
    if(!valve) return '';
    return `
      <div style="display: flex; justify-content: space-between; align-items: center; 
                  padding: 10px; background: #e8f5e9; border: 1px solid #4caf50; 
                  border-radius: 8px; margin-bottom: 8px;">
        <div style="flex: 1;">
          <div style="font-weight: 700; font-size: 13px;">${valve.name}</div>
          <div style="font-size: 11px; color: #666;">
            ${valve.id} â€¢ ${valve.households} HH â€¢ ${valve.mandal}
          </div>
        </div>
        <button class="btn danger" onclick="removeMainValve('${valveId}')" 
                style="margin: 0; padding: 6px 12px; font-size: 11px;">
          <i class="fas fa-times"></i> Remove
        </button>
      </div>
    `;
  }).join('');
  
  // Available valves dropdown (excluding already selected)
  const availableValves = mainValves.filter(v => !selectedValves.includes(v.id));
  const dropdownOptions = availableValves.map(v => 
    `<option value="${v.id}">${v.name} (${v.id}) - ${v.households} HH - ${v.mandal}</option>`
  ).join('');
  
  container.innerHTML = `
    <div style="margin-bottom: 16px;">
      <div style="font-weight: 600; font-size: 12px; color: var(--muted); margin-bottom: 8px;">
        CONNECTED MAIN VALVES (${selectedValves.length})
      </div>
      <div id="selectedValvesList">
        ${selectedValves.length > 0 ? selectedValvesDisplay : '<div style="text-align: center; padding: 20px; color: var(--muted); font-size: 12px;">No valves connected yet</div>'}
      </div>
    </div>
    
    <div style="border-top: 2px dashed var(--line); padding-top: 16px;">
      <div style="font-weight: 600; font-size: 12px; color: var(--muted); margin-bottom: 8px;">
        ADD MAIN VALVE
      </div>
      ${availableValves.length > 0 ? `
        <div style="display: flex; gap: 8px;">
          <select id="valveToAdd" style="flex: 1; padding: 10px; border: 1px solid var(--line); 
                                          border-radius: 8px; font-size: 13px;">
            <option value="">-- Select a valve to add --</option>
            ${dropdownOptions}
          </select>
          <button class="btn success" onclick="addMainValve()" 
                  style="margin: 0; padding: 10px 16px; white-space: nowrap;">
            <i class="fas fa-plus"></i> Add
          </button>
        </div>
        
        <div style="margin-top: 12px;">
          <input type="text" id="valveSearchInput" 
                 placeholder="ðŸ” Search valves by name, ID, or location..." 
                 style="width: 100%; padding: 10px; border: 1px solid var(--line); 
                        border-radius: 8px; font-size: 13px;"/>
        </div>
      ` : `
        <div style="text-align: center; padding: 20px; color: var(--success); font-size: 12px;">
          âœ… All main valves are connected!
        </div>
      `}
    </div>
  `;
  
  // Store selected valves in a global for easy access
  window.currentSelectedValves = [...selectedValves];
  
  // Add search functionality
  const searchInput = document.getElementById('valveSearchInput');
  if(searchInput) {
    searchInput.addEventListener('input', (e) => {
      const query = e.target.value.toLowerCase();
      const dropdown = document.getElementById('valveToAdd');
      const options = dropdown.querySelectorAll('option');
      
      options.forEach((option, idx) => {
        if(idx === 0) return; // Skip placeholder
        const text = option.textContent.toLowerCase();
        option.style.display = text.includes(query) ? 'block' : 'none';
      });
    });
  }
}

// Global functions for valve management (Place these OUTSIDE of populateMainValvesList)
window.addMainValve = function() {
  const dropdown = document.getElementById('valveToAdd');
  const valveId = dropdown.value;
  
  if(!valveId) {
    toast('âš ï¸ Please select a valve');
    return;
  }
  
  if(!window.currentSelectedValves.includes(valveId)) {
    window.currentSelectedValves.push(valveId);
    populateMainValvesList(window.currentSelectedValves);
    toast('âœ… Valve added');
  } else {
    toast('âš ï¸ Valve already connected');
  }
};

window.removeMainValve = function(valveId) {
  window.currentSelectedValves = window.currentSelectedValves.filter(id => id !== valveId);
  populateMainValvesList(window.currentSelectedValves);
  toast('âœ… Valve removed');
};

    function startDataCollection() {
  console.warn('â¸ï¸ Client-side data simulator disabled; using server analytics.');
  return;

  dataCollectionInterval = setInterval(async () => {
    // Track tanks with change detection
    // Track tanks with change detection
// Track tanks with change detection
// FIND THIS SECTION (around line 1170):
for(const tank of tanks) {
  // Store PREVIOUS state BEFORE generating new data
  const previousData = {
    waterLevel: tank.waterLevel,
    pressure: parseFloat(tank.pressure),
    flowRate: parseFloat(tank.flowRate),
    pH: parseFloat(tank.pH),
    temperature: parseFloat(tank.temperature),
    status: tank.status
  };
  
  // Get real device telemetry if available
  const deviceTelemetry = resolveDeviceTelemetry(tank);
  if (deviceTelemetry && deviceTelemetry.distance !== undefined && deviceTelemetry.distance !== null) {
    const calculatedWaterLevel = tank.calculateWaterLevelFromDistance(deviceTelemetry.distance);
    if (Math.abs(tank.waterLevel - calculatedWaterLevel) > 0.01) {
      tank.setWaterLevel(calculatedWaterLevel);
    }
  }
  
  // Calculate ETA for history (do this BEFORE detecting changes)
  const etaData = calculateTankETA(tank);
  
  // ADD THIS: Calculate household statistics for this tank
  const { stats } = calculateHouseholdStats();
  let tankHouseholds = 0;
  let tankServedHouseholds = 0;
  
  // Find households served by this tank's connected valves
  if (tank.connectedMainValves && tank.connectedMainValves.length > 0) {
    const connectedValves = valves.filter(v => 
      tank.connectedMainValves.includes(v.id) && v.category === 'main'
    );
    
    connectedValves.forEach(mainValve => {
      const mainData = stats.mainValves.find(m => m.valve.id === mainValve.id);
      if (mainData) {
        tankHouseholds += mainData.totalHouseholds;
        tankServedHouseholds += mainData.servedHouseholds;
      }
    });
  }


  
  // Detect changes by comparing previous vs current
  const changes = [];
  if (Math.abs(previousData.waterLevel - tank.waterLevel) > 0.01) {
    changes.push(`Water level: ${previousData.waterLevel}m â†’ ${tank.waterLevel}m`);
  }
  if (Math.abs(previousData.pressure - parseFloat(tank.pressure)) > 2) {
    changes.push(`Pressure: ${previousData.pressure} â†’ ${tank.pressure} PSI`);
  }
  if (Math.abs(previousData.flowRate - parseFloat(tank.flowRate)) > 5) {
    changes.push(`Flow rate: ${previousData.flowRate} â†’ ${tank.flowRate} L/min`);
  }
  if (Math.abs(previousData.pH - parseFloat(tank.pH)) > 0.3) {
    changes.push(`pH: ${previousData.pH} â†’ ${tank.pH}`);
  }
  
  await FirebaseService.saveTank(tank);
  
  // Save to history with changes, ETA, AND HOUSEHOLD DATA
  // Get valve states for this tank
const connectedValveStates = [];
if(tank.connectedMainValves && tank.connectedMainValves.length > 0) {
  tank.connectedMainValves.forEach(valveId => {
    const valve = valves.find(v => v.id === valveId);
    if(valve) {
      connectedValveStates.push({
        id: valve.id,
        name: valve.name,
        state: valve.active ? 'CLOSED' : 'OPEN'
      });
    }
  });
}

// Get real device data for history
const deviceTelemetryForHistory = resolveDeviceTelemetry(tank);
const historyData = {
  currentVolume: parseFloat(tank.calculateCurrentVolume()) || 0,
  mainFlowRate: parseFloat(etaData.currentFlow) || 0,
  householdSupply: tankServedHouseholds,
  pressureChange: parseFloat(tank.pressure) || 0,
  valveStates: connectedValveStates
};

// Add real device data if available
if (deviceTelemetryForHistory) {
  historyData.distance = deviceTelemetryForHistory.distance;
  historyData.distance_cm = deviceTelemetryForHistory.distance ? (deviceTelemetryForHistory.distance * 100).toFixed(1) : null;
  historyData.deviceTimestamp = deviceTelemetryForHistory.timestamp;
  historyData.waterLevel = tank.waterLevel;
}

await HistoryService.saveDataPoint(tank.id, 'tanks', historyData);
}   
    // Track valves with change detection
    // Track valves with change detection
for(const valve of valves) {
  // Store PREVIOUS state BEFORE generating new data
  const previousData = {
    valveState: valve.valveState,
    active: valve.active,
    battery: parseFloat(valve.battery),
    pressure: parseFloat(valve.pressure),
    households: valve.households
  };
  
  // Get real device telemetry if available (valves don't use distance, but can use other sensors)
  const valveDeviceTelemetry = resolveDeviceTelemetry(valve);
  if (valveDeviceTelemetry) {
    if (valveDeviceTelemetry.pressure !== undefined) valve.pressure = valveDeviceTelemetry.pressure;
    if (valveDeviceTelemetry.battery !== undefined) valve.battery = valveDeviceTelemetry.battery;
  }
  
  // Calculate supply info BEFORE changes
  const supplies = calculateSupplyPerHousehold();
  const supplyInfo = supplies.find(s => s.valveId === valve.id);
  
  // Detect changes by comparing previous vs current
  const changes = [];
  if (previousData.valveState !== valve.valveState) {
    changes.push(`Valve state: ${previousData.valveState.toUpperCase()} â†’ ${valve.valveState.toUpperCase()}`);
  }
  if (previousData.active !== valve.active) {
    changes.push(`Control: ${previousData.active ? 'CLOSED' : 'OPEN'} â†’ ${valve.active ? 'CLOSED' : 'OPEN'}`);
    changes.push(`${valve.households} households ${valve.active ? 'DISCONNECTED' : 'RECONNECTED'}`);
  }
  if (Math.abs(previousData.battery - parseFloat(valve.battery)) > 10) {
    changes.push(`Battery: ${previousData.battery}% â†’ ${valve.battery}%`);
  }
  if (Math.abs(previousData.pressure - parseFloat(valve.pressure)) > 3) {
    changes.push(`Pressure: ${previousData.pressure} â†’ ${valve.pressure} PSI`);
  }
  
  await FirebaseService.saveValve(valve);
  
  // Save to history with changes and supply data
  await HistoryService.saveDataPoint(valve.id, 'valves', {
    valveState: valve.valveState,
    battery: parseFloat(valve.battery),
    pressure: parseFloat(valve.pressure),
    active: valve.active,
    households: valve.households,
    changes: changes.length > 0 ? changes.join('; ') : 'No changes',
    supplyFlow: supplyInfo ? parseFloat(supplyInfo.totalFlow) : 0,
    avgSupplyPerHousehold: supplyInfo ? parseFloat(supplyInfo.avgSupply) : 0,
    householdsServed: valve.active ? 0 : valve.households
  });
}
    
    requestSupplyDashboardUpdate();
  }, DATA_COLLECTION_INTERVAL);
}

    // ==================== MODE CONTROL ====================
    function setMode(m) {
      mode = m;
      updateToolbar();
      if(m === 'pipeline') {
        canvas.classList.add('active');
        canvas.classList.remove('drawing');
        map.dragging.disable();
        map.scrollWheelZoom.disable();
        toast('âœ“ Pipeline mode: Click and drag to draw');
      } else if(m === 'erase') {
        canvas.classList.add('active');
        canvas.classList.remove('drawing');
        map.dragging.disable();
        map.scrollWheelZoom.disable();
        toast('âœ“ Erase mode: Click pipeline segments');
      } else {
        canvas.classList.remove('active', 'drawing');
        map.dragging.enable();
        map.scrollWheelZoom.enable();
        if(m === 'tank') { toast('âœ“ Tank mode: Click map to place tank'); }
        else if(m === 'valve') { toast('âœ“ Valve mode: Click pipeline to add valve'); }
      }
    }

    function updateToolbar() {
      setActive('toolPipeline', mode === 'pipeline');
      setActive('toolTank', mode === 'tank');
      setActive('toolValve', mode === 'valve');
      setActive('toolErase', mode === 'erase');
    }

    // ==================== HOVER TOOLTIPS ====================
    function showHoverTooltip(content, x, y) {
      const tooltip = document.getElementById('hoverTooltip');
      tooltip.innerHTML = content;
      tooltip.style.left = `${x + 10}px`;
      tooltip.style.top = `${y + 10}px`;
      tooltip.classList.add('active');
    }

    function hideHoverTooltip() {
      const tooltip = document.getElementById('hoverTooltip');
      tooltip.classList.remove('active');
    }

    function createTooltipContent(device, type) {
      const now = new Date();
      const timeStr = now.toLocaleTimeString('en-IN', {hour: '2-digit', minute: '2-digit'});
      
      if (type === 'tank') {
        const info = device.info();
        const currentVolume = device.calculateCurrentVolume().toFixed(0);
        const maxCapacity = device.calculateMaxCapacity().toFixed(0);
        const fillPercentage = ((parseFloat(currentVolume) / parseFloat(maxCapacity)) * 100).toFixed(1);
        
        return `
          <div class="tooltip-title">
            <i class="fas fa-water" style="color: #03a9f4;"></i> 
            ${device.name}
            <span class="status-indicator ${device.status === 'active' ? 'status-active' : 'status-inactive'}"></span>
            <span class="live-badge">LIVE</span>
          </div>
          
          <div style="font-size: 10px; color: rgba(255,255,255,0.6); margin-bottom: 8px;">
            Last updated: ${timeStr}
          </div>
          
          <div class="tooltip-section">
            <div class="tooltip-section-title">ðŸ“Š Storage Status</div>
            <div class="tooltip-row">
              <span class="tooltip-label">Type:</span>
              <span class="tooltip-value">${info.type} (${device.shape === 'cylinder' ? 'Cylinder' : 'Cuboid'})</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Current Volume:</span>
              <span class="tooltip-value" style="color: #03a9f4;">${parseInt(currentVolume).toLocaleString()} L</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Max Capacity:</span>
              <span class="tooltip-value">${parseInt(maxCapacity).toLocaleString()} L</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Fill Level:</span>
              <span class="tooltip-value" style="color: ${fillPercentage > 70 ? '#4caf50' : fillPercentage > 30 ? '#ff9800' : '#f44336'};">
                ${fillPercentage}%
              </span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Water Level:</span>
              <span class="tooltip-value">${info.waterLevel}</span>
            </div>
          </div>
          
          <div class="tooltip-section">
            <div class="tooltip-section-title">âš¡ Live Metrics</div>
            <div class="tooltip-row">
              <span class="tooltip-label">Pressure:</span>
              <span class="tooltip-value" style="color: #ff9800;">${info.pressure}</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Flow Rate:</span>
              <span class="tooltip-value" style="color: #2196f3;">${info.flowRate}</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">pH Level:</span>
              <span class="tooltip-value">${info.pH}</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Temperature:</span>
              <span class="tooltip-value">${info.temperature}</span>
            </div>
          </div>
          
          <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 10px; color: rgba(255,255,255,0.6); text-align: center;">
            Click for detailed analysis
          </div>
        `;
      } else if (type === 'valve') {
        const info = device.info();
        const supplies = calculateSupplyPerHousehold();
        const supplyInfo = supplies.find(s => s.valveId === device.id);
        const analyticsValve = analyticsState?.valves?.[device.id] || null;
        const valveDeviceTelemetry =
          analyticsState?.devices?.[device.id] ||
          resolveDeviceTelemetry(device);
        const valveLiveMetrics = {
          battery: valveDeviceTelemetry?.battery !== undefined ? `${valveDeviceTelemetry.battery}%` : (info.battery || 'â€”'),
          pressure: valveDeviceTelemetry?.pressure !== undefined ? `${valveDeviceTelemetry.pressure} PSI` : (info.pressure || 'â€”')
        };
        const valveTelemetryDistance = valveDeviceTelemetry?.distance_meters ?? valveDeviceTelemetry?.distanceMeters ?? null;
        const valveDeviceTimestamp = valveDeviceTelemetry?.timestamp ? new Date(valveDeviceTelemetry.timestamp).toLocaleString() : 'â€”';
        
        return `
          <div class="tooltip-title">
            <i class="fas fa-cog" style="color: #6a1b9a;"></i> 
            ${device.name}
            <span class="status-indicator ${device.active ? 'status-inactive' : 'status-active'}"></span>
            <span class="live-badge">LIVE</span>
          </div>
          
          <div style="font-size: 10px; color: rgba(255,255,255,0.6); margin-bottom: 8px;">
            Last updated: ${timeStr}
          </div>
          
          <div class="tooltip-section">
            <div class="tooltip-section-title">â„¹ï¸ Valve Info</div>
            <div class="tooltip-row">
              <span class="tooltip-label">Type:</span>
              <span class="tooltip-value">${info.type}</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Category:</span>
              <span class="tooltip-value">${info.category.toUpperCase()}</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Status:</span>
              <span class="tooltip-value" style="color: ${device.active ? '#f44336' : '#4caf50'};">
                ${info.valveState.toUpperCase()}
              </span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Location:</span>
              <span class="tooltip-value">${device.mandal}</span>
            </div>
          </div>
          
          <div class="tooltip-section">
            <div class="tooltip-section-title">ðŸ˜ï¸ Household Supply</div>
            <div class="tooltip-row">
              <span class="tooltip-label">Households:</span>
              <span class="tooltip-value" style="color: #6a1b9a;">${info.households}</span>
            </div>
            ${supplyInfo ? `
              <div class="tooltip-row">
                <span class="tooltip-label">Supply Flow:</span>
                <span class="tooltip-value" style="color: #2196f3;">${supplyInfo.totalFlow.toFixed(1)} L/min</span>
              </div>
              <div class="tooltip-row">
                <span class="tooltip-label">Avg per HH:</span>
                <span class="tooltip-value" style="color: #4caf50;">${supplyInfo.avgSupply.toFixed(2)} L/min</span>
              </div>
            ` : `
              <div style="text-align: center; padding: 8px; color: rgba(255,255,255,0.5); font-size: 11px;">
                ${device.active ? 'ðŸ”´ Valve closed - No supply' : 'No flow data available'}
              </div>
            `}
          </div>
          
          <div class="tooltip-section">
            <div class="tooltip-section-title">ðŸ“Š Sensors</div>
            <div class="tooltip-row">
              <span class="tooltip-label">Battery:</span>
              <span class="tooltip-value" style="color: ${parseInt(info.battery) > 70 ? '#4caf50' : parseInt(info.battery) > 30 ? '#ff9800' : '#f44336'};">
                ${info.battery}
              </span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Pressure:</span>
              <span class="tooltip-value">${info.pressure}</span>
            </div>
          </div>
          
          <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 10px; color: rgba(255,255,255,0.6); text-align: center;">
            Click for control panel
          </div>
        `;
      } else if (type === 'pipeline') {
        const pipe = device;
        const flowPercentage = pipe.capacity > 0 ? ((pipe.currentFlow / pipe.capacity) * 100).toFixed(1) : 0;
        
        return `
          <div class="tooltip-title">
            <i class="fas fa-pipe" style="color: #1e88e5;"></i> 
            ${pipe.name}
            <span class="status-indicator ${pipe.currentFlow > 0 ? 'status-active' : 'status-inactive'}"></span>
          </div>
          
          <div class="tooltip-section">
            <div class="tooltip-section-title">ðŸ”§ Pipeline Specs</div>
            <div class="tooltip-row">
              <span class="tooltip-label">Material:</span>
              <span class="tooltip-value">${pipe.type}</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Diameter:</span>
              <span class="tooltip-value">${pipe.diameter}mm</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Max Capacity:</span>
              <span class="tooltip-value">${pipe.capacity} L/min</span>
            </div>
          </div>
          
          <div class="tooltip-section">
            <div class="tooltip-section-title">ðŸ’§ Current Flow</div>
            <div class="tooltip-row">
              <span class="tooltip-label">Flow Rate:</span>
              <span class="tooltip-value" style="color: ${pipe.currentFlow > 0 ? '#4caf50' : '#f44336'};">
                ${pipe.currentFlow.toFixed(0)} L/min
              </span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Capacity Usage:</span>
              <span class="tooltip-value" style="color: ${flowPercentage > 80 ? '#f44336' : flowPercentage > 50 ? '#ff9800' : '#4caf50'};">
                ${flowPercentage}%
              </span>
            </div>
          </div>
          
          <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 10px; color: rgba(255,255,255,0.6); text-align: center;">
            ${pipe.startPoint && pipe.endPoint ? `${pipe.startPoint} â†’ ${pipe.endPoint}` : 'Click for details'}
          </div>
        `;
      }
      return '';
    }

    // ==================== MAP INTERACTIONS ====================
    function onMapClick(e) {
      const latLng = e.latlng;
      if(mode === 'erase') return;
      
      const clickedTank = tanks.find(t => distanceInPixels(t, latLng) < CLICK_DETECT_RADIUS);
      if(clickedTank) { showDevice(clickedTank, 'tank'); return; }
      
      const clickedValve = valves.find(v => distanceInPixels(v, latLng) < CLICK_DETECT_RADIUS);
      if(clickedValve) { showDevice(clickedValve, 'valve'); return; }

     if(mode === 'tank') {
  openModal('tankModal');
  setText('tankModalTitle', 'Add Tank');
  setValue('tankLat', latLng.lat.toFixed(6));
  setValue('tankLng', latLng.lng.toFixed(6));
  setValue('tankId', '');
  setValue('tankWaterLevel', '8.5');
  document.getElementById('tankModal').removeAttribute('data-edit-id');
  document.getElementById('tankIdError').textContent = '';
  populateMainValvesList([]); // Populate with empty selection
} else if(mode === 'valve') {
        if(isOnAnyPipeline(latLng, 20)) {
          openModal('valveModal');
          setText('valveModalTitle', 'Add Valve');
          setValue('valveLat', latLng.lat.toFixed(6));
          setValue('valveLng', latLng.lng.toFixed(6));
          setValue('valveId', '');
          setValue('valveCategory', 'sub');
          setValue('valveHouseholds', '10');
          document.getElementById('parentValveRow').style.display = 'block';
          updateParentValveList();
          document.getElementById('valveModal').removeAttribute('data-edit-id');
          document.getElementById('valveIdError').textContent = '';
        } else {
          toast('âš ï¸ Place valve on a pipeline');
        }
      }
    }

    function onMapRightClick(e) {
      e.originalEvent.preventDefault();
      const {lat, lng} = e.latlng;
      setValue('tankLat', lat.toFixed(6));
      setValue('tankLng', lng.toFixed(6));
      setValue('valveLat', lat.toFixed(6));
      setValue('valveLng', lng.toFixed(6));
      toast('ðŸ“ Coordinates filled');
    }

    async function eraseSegmentAtPoint(latLng) {
      let foundSegment = false;
      for(let i = 0; i < pipelines.length; i++) {
        const pipe = pipelines[i];
        for(let j = 0; j < pipe.points.length - 1; j++) {
          if(pointOnSegment(latLng, pipe.points[j], pipe.points[j+1], 20)) {
            foundSegment = true;
            const pipelineName = pipe.name || `Pipeline ${i + 1}`;
            const action = await new Promise(resolve => {
              const modal = document.createElement('div');
              modal.className = 'modal active';
              modal.innerHTML = `
                <div class="modal-content" style="max-width:500px">
                  <div class="modal-header">
                    <h3>Erase Pipeline Segment</h3>
                  </div>
                  <div class="modal-body">
                    <p style="margin-bottom:16px;font-size:14px">
                      <strong>Pipeline:</strong> ${pipelineName}<br>
                      <strong>Segment:</strong> ${j + 1} of ${pipe.points.length - 1}
                    </p>
                    <button class="btn danger" id="eraseSegmentBtn" style="margin-bottom:8px">
                      <i class="fas fa-cut"></i> Split Pipeline Here
                    </button>
                    <button class="btn danger" id="deleteEntireBtn" style="margin-bottom:8px">
                      <i class="fas fa-trash"></i> Delete Entire Pipeline
                    </button>
                    <button class="btn" id="cancelEraseBtn">
                      <i class="fas fa-times"></i> Cancel
                    </button>
                  </div>
                </div>
              `;
              document.body.appendChild(modal);
              document.getElementById('eraseSegmentBtn').onclick = () => { document.body.removeChild(modal); resolve('split'); };
              document.getElementById('deleteEntireBtn').onclick = () => { document.body.removeChild(modal); resolve('delete'); };
              document.getElementById('cancelEraseBtn').onclick = () => { document.body.removeChild(modal); resolve('cancel'); };
            });
            if(action === 'split') {
              const remaining = pipe.points.slice(0, j + 1);
              if(remaining.length > 1) {
                pipe.points = remaining;
                pipe.update({points: remaining});
                await FirebaseService.savePipeline(pipe);
                toast('âœ“ Pipeline split');
              } else {
                await FirebaseService.deletePipeline(pipe.id);
                toast('âœ“ Pipeline deleted');
              }
            } else if(action === 'delete') {
              await FirebaseService.deletePipeline(pipe.id);
              toast('âœ“ Pipeline deleted');
            } else {
              toast('âŒ Erase cancelled');
            }
            flowCacheDirty = true;
            requestDrawCanvas();
            requestSupplyDashboardUpdate();
            return;
          }
        }
      }
      if(!foundSegment) toast('âš ï¸ Click on a pipeline segment');
    }

    // ==================== CANVAS DRAWING ====================
    function handleCanvasMouseDown(e) {
      if(mode === 'erase') {
        e.preventDefault(); e.stopPropagation();
        const latLng = pixelToLatLng(eventToPixel(e));
        eraseSegmentAtPoint(latLng);
        return;
      }
      if(mode !== 'pipeline') return;
      e.preventDefault(); e.stopPropagation();
      const latLng = pixelToLatLng(eventToPixel(e));
      isDrawing = true;
      currentPipeline = [latLng];
      canvas.classList.add('drawing');
    }

    function handleCanvasMouseMove(e) {
      const px = eventToPixel(e);
      const latLng = pixelToLatLng(px);
      
      // Handle hover tooltips
      const hoveredTank = tanks.find(t => distanceInPixels(t, latLng) < CLICK_DETECT_RADIUS);
      const hoveredValve = valves.find(v => distanceInPixels(v, latLng) < CLICK_DETECT_RADIUS);
      let hoveredPipeline = null;
      
      if(mode === 'erase') {
        for(let i = 0; i < pipelines.length; i++) {
          const pipe = pipelines[i];
          for(let j = 0; j < pipe.points.length - 1; j++) {
            if(pointOnSegment(latLng, pipe.points[j], pipe.points[j+1], 20)) {
              hoveredPipeline = {pipe, segmentIndex: j};
              break;
            }
          }
          if(hoveredPipeline) break;
        }
      }
      
      hoveredDevice = hoveredTank ? {type:'tank', device:hoveredTank} : 
                      hoveredValve ? {type:'valve', device:hoveredValve} : 
                      hoveredPipeline ? {type:'pipeline', data:hoveredPipeline} : null;
      
      // Show/hide tooltip based on hover state
      if (hoveredDevice) {
        const tooltipContent = createTooltipContent(
          hoveredDevice.type === 'pipeline' ? hoveredDevice.data.pipe : hoveredDevice.device,
          hoveredDevice.type
        );
        showHoverTooltip(tooltipContent, e.clientX, e.clientY);
      } else {
        hideHoverTooltip();
      }
      
      if(mode === 'erase') canvas.style.cursor = hoveredPipeline ? 'crosshair' : 'not-allowed';
      
      if(isDrawing && mode === 'pipeline') {
        e.preventDefault();
        const lastLatLng = currentPipeline[currentPipeline.length-1];
        const lastPx = latLngToPixel(lastLatLng);
        if(distanceBetweenPixels(lastPx, px) > 3) {
          currentPipeline.push(latLng);
          requestDrawCanvas();
        }
      }
    }

    async function handleCanvasMouseUp(e) {
      if(!isDrawing) return;
      e.preventDefault(); e.stopPropagation();
      if(currentPipeline.length > 5) {
        const newPipe = new Pipeline({points: currentPipeline});
        await FirebaseService.savePipeline(newPipe);
        toast('âœ“ Pipeline created!');
        openPipelineDetailsModal(newPipe.id);
      } else {
        toast('âš ï¸ Pipeline too short');
      }
      currentPipeline = [];
      isDrawing = false;
      canvas.classList.remove('drawing');
      map.dragging.enable();
      map.scrollWheelZoom.enable();
      flowCacheDirty = true;
      requestDrawCanvas();
      requestSupplyDashboardUpdate();
    }

    function openPipelineDetailsModal(pipeId) {
      const pipe = pipelines.find(p => p.id === pipeId);
      if(!pipe) return;
      openModal('pipelineModal');
      setValue('pipelineName', pipe.name);
      setValue('pipelineType', pipe.type);
      setValue('pipelineDiameter', pipe.diameter);
      setValue('pipelineCapacity', pipe.capacity);
      setValue('pipelineStart', pipe.startPoint);
      setValue('pipelineEnd', pipe.endPoint);
      setValue('pipelineNotes', pipe.notes);
      document.getElementById('pipelineModal').setAttribute('data-pipe-id', pipeId);
    }

    async function onSavePipeline() {
      const pipeId = document.getElementById('pipelineModal').getAttribute('data-pipe-id');
      const pipe = pipelines.find(p => p.id === pipeId);
      if(!pipe) return;

      const name = val('pipelineName').trim();
      const type = val('pipelineType');
      const diameter = parseFloat(val('pipelineDiameter'));
      const capacity = parseFloat(val('pipelineCapacity'));
      const startPoint = val('pipelineStart').trim();
      const endPoint = val('pipelineEnd').trim();
      const notes = val('pipelineNotes').trim();

      if(!name || isNaN(diameter) || isNaN(capacity)) { toast('âš ï¸ Fill all required fields'); return; }

      pipe.update({name, type, diameter, capacity, startPoint, endPoint, notes});
      await FirebaseService.savePipeline(pipe);
      closeModal('pipelineModal');
      toast('âœ“ Pipeline saved');
      flowCacheDirty = true;
      requestDrawCanvas();
      requestSupplyDashboardUpdate();
      setMode('pipeline');
    }

    // ==================== SEARCH ====================
    function levenshteinDistance(a, b) {
      const matrix = [];
      for(let i = 0; i <= b.length; i++) matrix[i] = [i];
      for(let j = 0; j <= a.length; j++) matrix[0][j] = j;
      for(let i = 1; i <= b.length; i++) {
        for(let j = 1; j <= a.length; j++) {
          if(b.charAt(i-1) === a.charAt(j-1)) matrix[i][j] = matrix[i-1][j-1];
          else matrix[i][j] = Math.min(matrix[i-1][j-1] + 1, matrix[i][j-1] + 1, matrix[i-1][j] + 1);
        }
      }
      return matrix[b.length][a.length];
    }

    function fuzzyMatch(query, target) {
      const q = query.toLowerCase();
      const t = target.toLowerCase();
      if(t.includes(q)) return 100;
      const distance = levenshteinDistance(q, t);
      const maxLen = Math.max(q.length, t.length);
      return Math.max(0, 100 - (distance / maxLen) * 100);
    }

    async function onSearchInput() {
      const query = document.getElementById('searchInput').value.trim();
      if(!query || query.length < 2) { hideSuggestions(); return; }
      showLoadingSuggestions();
      const deviceResults = searchDevices(query);
      const locationResults = await searchLocations(query);
      renderSuggestions(deviceResults, locationResults);
    }

    function searchDevices(query) {
      const q = query.toLowerCase();
      const results = [];
      tanks.forEach(t => {
        const nameScore = fuzzyMatch(q, t.name);
        const idScore = fuzzyMatch(q, t.id);
        const locationScore = Math.max(
          fuzzyMatch(q, t.state || ''),
          fuzzyMatch(q, t.district || ''),
          fuzzyMatch(q, t.mandal || ''),
          fuzzyMatch(q, t.habitation || '')
        );
        const score = Math.max(nameScore, idScore, locationScore);
        if(score > 50) results.push({type:'tank', device:t, score});
      });
      valves.forEach(v => {
        const nameScore = fuzzyMatch(q, v.name);
        const idScore = fuzzyMatch(q, v.id);
        const locationScore = Math.max(
          fuzzyMatch(q, v.mandal || ''),
          fuzzyMatch(q, v.habitation || '')
        );
        const score = Math.max(nameScore, idScore, locationScore);
        if(score > 50) results.push({type:'valve', device:v, score});
      });
      results.sort((a, b) => b.score - a.score);
      return results.slice(0, 5);
    }

    async function searchLocations(query) {
      try {
        const response = await fetch(
          `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&countrycodes=in`,
          { headers: { 'User-Agent': 'WaterDistributionApp/1.0' } }
        );
        if(!response.ok) return [];
        const data = await response.json();
        return data.map(place => ({
          name: place.display_name,
          lat: parseFloat(place.lat),
          lng: parseFloat(place.lon),
          type: place.type,
          importance: place.importance || 0
        }));
      } catch(error) { console.error('Location search error:', error); return []; }
    }

    function renderSuggestions(devices, locations) {
      const holder = document.getElementById('suggestions');
      const list = document.getElementById('suggestList');
      
      if(devices.length === 0 && locations.length === 0) {
        list.innerHTML = '<div class="suggest-item" style="text-align:center;color:var(--muted)">No results found</div>';
        holder.style.display = 'block';
        return;
      }

      let html = '';
      if(devices.length > 0) {
        html += '<div class="suggest-item header">DEVICES</div>';
        devices.forEach(d => {
          const icon = d.type === 'tank' ? 'fa-water' : 'fa-cog';
          const color = d.type === 'tank' ? '#0288d1' : '#6a1b9a';
          const location = d.device.habitation || d.device.mandal || 'Unknown';
          html += `<div class="suggest-item" data-type="device" data-device-type="${d.type}" data-device-id="${d.device.id}">
            <i class="fas ${icon}" style="color:${color};font-size:18px"></i>
            <div style="flex:1">
              <div style="font-weight:600">${d.device.name}</div>
              <div style="font-size:11px;color:var(--muted)">${d.device.id} â€¢ ${location}</div>
            </div>
            <span class="match-score">${d.score.toFixed(0)}%</span>
          </div>`;
        });
      }
      if(locations.length > 0) {
        html += '<div class="suggest-item header">LOCATIONS</div>';
        locations.forEach((loc, idx) => {
          const icon = getLocationIcon(loc.type);
          html += `<div class="suggest-item" data-type="location" data-location-index="${idx}">
            <i class="fas ${icon}" style="color:#e67e22;font-size:18px"></i>
            <div style="flex:1">
              <div style="font-weight:600">${getLocationTitle(loc.name)}</div>
              <div style="font-size:11px;color:var(--muted)">${getLocationSubtitle(loc.name)}</div>
            </div>
            <i class="fas fa-map-marker-alt" style="color:var(--muted);font-size:12px"></i>
          </div>`;
        });
      }
      list.innerHTML = html;

      list.querySelectorAll('.suggest-item[data-type="device"]').forEach(item => {
        item.addEventListener('click', () => {
          const deviceType = item.getAttribute('data-device-type');
          const deviceId = item.getAttribute('data-device-id');
          const device = deviceType === 'tank' ? tanks.find(t => t.id === deviceId) : valves.find(v => v.id === deviceId);
          if(device) {
            map.setView([device.lat, device.lng], 17);
            showDevice(device, deviceType);
            hideSuggestions();
            document.getElementById('searchInput').value = '';
          }
        });
      });

      list.querySelectorAll('.suggest-item[data-type="location"]').forEach(item => {
        item.addEventListener('click', () => {
          const index = parseInt(item.getAttribute('data-location-index'));
          const location = locations[index];
          if(location) {
            map.setView([location.lat, location.lng], 15);
            addTemporaryMarker(location);
            hideSuggestions();
            document.getElementById('searchInput').value = getLocationTitle(location.name);
            toast(`ðŸ“ ${getLocationTitle(location.name)}`);
          }
        });
      });

      holder.style.display = 'block';
    }

    function getLocationIcon(type) {
      const iconMap = { city:'fa-city', town:'fa-building', village:'fa-home', hamlet:'fa-house', administrative:'fa-landmark', state:'fa-map', district:'fa-map-marked', suburb:'fa-building', neighbourhood:'fa-map-pin', road:'fa-road', residential:'fa-home' };
      return iconMap[type] || 'fa-map-marker-alt';
    }

    function getLocationTitle(displayName) {
      const parts = displayName.split(',');
      return parts[0].trim();
    }

    function getLocationSubtitle(displayName) {
      const parts = displayName.split(',');
      if(parts.length > 1) return parts.slice(1, 3).join(',').trim();
      return '';
    }

    let temporaryMarker = null;
    function addTemporaryMarker(location) {
      if(temporaryMarker) map.removeLayer(temporaryMarker);
      temporaryMarker = L.marker([location.lat, location.lng], {
        icon: L.divIcon({
          className: 'temp-location-marker',
          html: '<div style="background:#e67e22;width:24px;height:24px;border-radius:50%;border:3px solid white;box-shadow:0 2px 8px rgba(0,0,0,0.3)"></div>',
          iconSize: [24, 24],
          iconAnchor: [12, 12]
        })
      }).addTo(map);
      temporaryMarker.bindPopup(`
        <div style="padding:8px">
          <strong>${getLocationTitle(location.name)}</strong><br>
          <small style="color:#666">${getLocationSubtitle(location.name)}</small>
        </div>
      `).openPopup();
      setTimeout(() => { if(temporaryMarker) { map.removeLayer(temporaryMarker); temporaryMarker = null; } }, 10000);
    }

    function showLoadingSuggestions() {
      const holder = document.getElementById('suggestions');
      const list = document.getElementById('suggestList');
      list.innerHTML = '<div class="suggest-item" style="text-align:center"><i class="fas fa-spinner fa-spin"></i> Searching...</div>';
      holder.style.display = 'block';
    }

    function hideSuggestions() { document.getElementById('suggestions').style.display = 'none'; }

    async function executeSearch() {
      const query = document.getElementById('searchInput').value.trim().toLowerCase();
      if(!query) { toast('âš ï¸ Enter search query'); return; }
      let device = [...tanks, ...valves].find(d => d.id.toLowerCase() === query);
      if(!device) {
        const matches = [...tanks, ...valves].filter(d => 
          fuzzyMatch(query, d.name) > 70 || fuzzyMatch(query, d.id) > 70
        ).sort((a, b) => {
          const scoreA = Math.max(fuzzyMatch(query, a.name), fuzzyMatch(query, a.id));
          const scoreB = Math.max(fuzzyMatch(query, b.name), fuzzyMatch(query, b.id));
          return scoreB - scoreA;
        });
        if(matches.length > 0) device = matches[0];
      }
      if(device) {
        const type = tanks.includes(device) ? 'tank' : 'valve';
        map.setView([device.lat, device.lng], 17);
        showDevice(device, type);
        hideSuggestions();
        toast(`âœ“ Found: ${device.name}`);
        return;
      }
      showLoading(true);
      const locations = await searchLocations(query);
      showLoading(false);
      if(locations.length > 0) {
        const location = locations[0];
        map.setView([location.lat, location.lng], 15);
        addTemporaryMarker(location);
        hideSuggestions();
        toast(`ðŸ“ ${getLocationTitle(location.name)}`);
        return;
      }
      toast('âŒ No results found');
    }

    // ==================== CRUD ====================
    function validateDeviceId(id, excludeId = null) {
      if(!id || id.trim().length === 0) return 'Device ID is required';
      const trimmedId = id.trim();
      if(trimmedId.length > 50) return 'Device ID must be 50 characters or less';
      const exists = [...tanks, ...valves].some(d => d.id === trimmedId && d.id !== excludeId);
      if(exists) return 'Device ID already exists';
      return null;
    }

   async function onSaveTank() {
  const id = val('tankId').trim();
  const name = val('tankName').trim();
  const type = val('tankType');
  const shape = val('tankShape');
  const capacity = parseFloat(val('tankCapacity'));
  const waterLevel = parseFloat(val('tankWaterLevel'));
  // Normalize device ID: trim, convert to uppercase for consistency
  let deviceId = val('tankDeviceId').trim() || null;
  if (deviceId) {
    deviceId = deviceId.toUpperCase(); // Normalize to uppercase for consistency with Firebase keys
  }
  const lat = parseFloat(val('tankLat'));
  const lng = parseFloat(val('tankLng'));
  const state = val('tankState').trim();
  const district = val('tankDistrict').trim();
  const mandal = val('tankMandal').trim();
  const habitation = val('tankHabitation').trim();
  
  // Get dimensions based on shape
  let diameter, height, length, breadth, sensorHeight;
  if(shape === 'cylinder') {
    diameter = parseFloat(val('tankDiameter'));
    height = parseFloat(val('tankHeight'));
    sensorHeight = parseFloat(val('tankSensorHeight')) || height;
    if(isNaN(diameter) || isNaN(height)) {
      toast('âš ï¸ Enter valid cylinder dimensions');
      return;
    }
  } else if(shape === 'cuboid') {
    length = parseFloat(val('tankLength'));
    breadth = parseFloat(val('tankBreadth'));
    height = parseFloat(val('tankHeightCuboid'));
    sensorHeight = parseFloat(val('tankSensorHeight')) || height;
    if(isNaN(length) || isNaN(breadth) || isNaN(height)) {
      toast('âš ï¸ Enter valid cuboid dimensions');
      return;
    }
  }
  
  // Get selected main valves
  // Get selected main valves from global storage
  const selectedValves = window.currentSelectedValves || [];

  const editingId = document.getElementById('tankModal').getAttribute('data-edit-id');
  const idError = validateDeviceId(id, editingId);
  if(idError) { 
    document.getElementById('tankIdError').textContent = idError; 
    return; 
  }
  if(!name || isNaN(lat) || isNaN(lng) || isNaN(capacity) || isNaN(waterLevel)) { 
    toast('âš ï¸ Fill all required fields'); 
    return; 
  }

  // Build tankData object with shape-specific fields
  const tankData = {
    id, name, type, shape, capacity, waterLevel, 
    height, sensorHeight,
    deviceId, state, district, mandal, habitation, lat, lng,
    connectedMainValves: selectedValves
  };
  
  // Only include shape-specific dimensions (don't set undefined values)
  if(shape === 'cylinder') {
    tankData.diameter = diameter;
  } else if(shape === 'cuboid') {
    tankData.length = length;
    tankData.breadth = breadth;
  }

  if(editingId) {
    const tank = tanks.find(t => t.id === editingId);
    if(tank) {
      // When updating, preserve existing values for fields not relevant to current shape
      // Only update the fields that are provided in tankData
      const updateData = { ...tankData };
      // Remove shape-incompatible fields from existing tank
      if(shape === 'cylinder') {
        delete updateData.length;
        delete updateData.breadth;
      } else if(shape === 'cuboid') {
        delete updateData.diameter;
      }
      tank.update(updateData);
      await FirebaseService.saveTank(tank);
      toast('âœ“ Tank updated');
    }
  } else {
    const tank = new Tank(tankData);
    await FirebaseService.saveTank(tank);
    toast('âœ“ Tank added');
  }
  
  document.getElementById('tankModal').removeAttribute('data-edit-id');
  document.getElementById('tankIdError').textContent = '';
  closeModal('tankModal');
  flowCacheDirty = true;
  requestDrawCanvas();
  requestSupplyDashboardUpdate();
  setMode('pipeline');
}

async function onSaveValve() {
  const id = val('valveId').trim();
  const name = val('valveName').trim();
  const type = val('valveType');
  const category = val('valveCategory');
  const parentValveId = category === 'sub' ? val('parentValve') : null;
  const households = parseInt(val('valveHouseholds'));
  const flowRate = parseFloat(val('valveFlowRate')); // NEW
  const lat = parseFloat(val('valveLat'));
  const lng = parseFloat(val('valveLng'));
  const mandal = val('valveMandal').trim();
  const habitation = val('valveHabitation').trim();

      const editingId = document.getElementById('valveModal').getAttribute('data-edit-id');
      const idError = validateDeviceId(id, editingId);
      if(idError) { document.getElementById('valveIdError').textContent = idError; return; }
      if(!name || isNaN(lat) || isNaN(lng) || isNaN(households)) { toast('âš ï¸ Fill all required fields'); return; }

      if(editingId) {
  const valve = valves.find(v => v.id === editingId);
  if(valve) {
    valve.update({id, name, type, category, parentValveId, households, flowRate, mandal, habitation, lat, lng});
    await FirebaseService.saveValve(valve);
    toast('âœ“ Valve updated');
  }
} else {
  if(!isOnAnyPipeline({lat, lng}, 20)) { toast('âš ï¸ Valve must be on a pipeline'); return; }
  const valve = new Valve({id, name, type, category, parentValveId, households, flowRate, mandal, habitation, lat, lng});
  await FirebaseService.saveValve(valve);
  toast('âœ“ Valve added');
}
      document.getElementById('valveModal').removeAttribute('data-edit-id');
      document.getElementById('valveIdError').textContent = '';
      closeModal('valveModal');
      flowCacheDirty = true;
      requestDrawCanvas();
  requestSupplyDashboardUpdate();
    }

    function editTank(id) {
  const tank = tanks.find(t => t.id === id);
  if(!tank) return;
  
  setText('tankModalTitle', 'Edit Tank');
  openModal('tankModal');
  document.getElementById('tankModal').setAttribute('data-edit-id', id);
  
  setValue('tankId', tank.id);
  setValue('tankName', tank.name);
  setValue('tankType', tank.type);
  setValue('tankShape', tank.shape || (tank.type === 'GSR' ? 'cuboid' : 'cylinder'));
  setValue('tankCapacity', tank.capacity);
  setValue('tankWaterLevel', tank.waterLevel);
  
  // Set dimensions
  if(tank.shape === 'cylinder' || !tank.shape) {
    setValue('tankDiameter', tank.diameter || 10);
    setValue('tankHeight', tank.height || 10);
    document.getElementById('cylinderDimensions').style.display = 'block';
    document.getElementById('cuboidDimensions').style.display = 'none';
  } else {
    setValue('tankLength', tank.length || 10);
    setValue('tankBreadth', tank.breadth || 10);
    setValue('tankHeightCuboid', tank.height || 10);
    document.getElementById('cylinderDimensions').style.display = 'none';
    document.getElementById('cuboidDimensions').style.display = 'block';
  }
  
  setValue('tankDeviceId', tank.deviceId || '');
  setValue('tankSensorHeight', tank.sensorHeight || tank.height || 10);
  setValue('tankState', tank.state);
  setValue('tankDistrict', tank.district);
  setValue('tankMandal', tank.mandal);
  setValue('tankHabitation', tank.habitation);
  setValue('tankLat', tank.lat);
  setValue('tankLng', tank.lng);
  
  document.getElementById('tankIdError').textContent = '';
  populateMainValvesList(tank.connectedMainValves || []);
}

    function editValve(id) {
  const valve = valves.find(v => v.id === id);
  if(!valve) return;
  setText('valveModalTitle', 'Edit Valve');
  openModal('valveModal');
  document.getElementById('valveModal').setAttribute('data-edit-id', id);
  setValue('valveId', valve.id);
  setValue('valveName', valve.name);
  setValue('valveType', valve.type);
  setValue('valveCategory', valve.category);
  setValue('valveHouseholds', valve.households);
  setValue('valveFlowRate', valve.flowRate); // NEW
  setValue('valveMandal', valve.mandal);
  setValue('valveHabitation', valve.habitation);
  setValue('valveLat', valve.lat);
  setValue('valveLng', valve.lng);
      if(valve.category === 'sub') {
        document.getElementById('parentValveRow').style.display = 'block';
        updateParentValveList();
        setValue('parentValve', valve.parentValveId || '');
      } else {
        document.getElementById('parentValveRow').style.display = 'none';
      }
      document.getElementById('valveIdError').textContent = '';
    }

    async function deleteTank(id) {
      if(!confirm('Delete this tank?')) return;
      await FirebaseService.deleteTank(id);
      closeSidebar();
      flowCacheDirty = true;
      requestDrawCanvas();
      requestSupplyDashboardUpdate();
      toast('âœ“ Tank deleted');
      if(document.getElementById('manageModal').classList.contains('active')) renderManage('tanks');
    }

    async function deleteValve(id) {
      if(!confirm('Delete this valve?')) return;
      await FirebaseService.deleteValve(id);
      closeSidebar();
      flowCacheDirty = true;
      requestDrawCanvas();
      requestSupplyDashboardUpdate();
      toast('âœ“ Valve deleted');
      if(document.getElementById('manageModal').classList.contains('active')) renderManage('valves');
    }

    async function deletePipeline(id) {
      if(!confirm('Delete this pipeline?')) return;
      await FirebaseService.deletePipeline(id);
      flowCacheDirty = true;
      requestDrawCanvas();
      requestSupplyDashboardUpdate();
      toast('âœ“ Pipeline deleted');
      renderManage('pipelines');
      closeModal('pipelineModal');
    }

    function editPipeline(id) { openPipelineDetailsModal(id); }

    function centerPipeline(id) {
      const pipe = pipelines.find(p => p.id === id);
      if(!pipe || pipe.points.length === 0) return;
      const mid = pipe.points[Math.floor(pipe.points.length / 2)];
      map.setView([mid.lat, mid.lng], Math.max(map.getZoom(), 16));
      closeModal('manageModal');
    }

    async function clearAll() {
      if(!confirm('âš ï¸ Clear ALL data?')) return;
      showLoading(true);
      await FirebaseService.clearAll();
      isDrawing = false;
      currentPipeline = [];
      closeSidebar();
      flowCacheDirty = true;
      requestDrawCanvas();
      requestSupplyDashboardUpdate();
      showLoading(false);
      toast('âœ“ All data cleared');
    }

    // ==================== MANAGE MODAL ====================
    function openManage() {
      openModal('manageModal');
      document.querySelectorAll('#manageModal [data-tab]').forEach(b => b.classList.remove('primary'));
      document.querySelector('#manageModal [data-tab="tanks"]').classList.add('primary');
      renderManage('tanks');
    }

    function renderManage(tab) {
      const content = document.getElementById('manageContent');
      if(tab === 'tanks') {
        if(tanks.length === 0) { content.innerHTML = '<div class="card" style="text-align:center;color:var(--muted)">No tanks</div>'; return; }
        content.innerHTML = '<div class="manage-list">' + tanks.map(t => `
          <div class="manage-item">
            <div class="manage-item-info">
              <div class="manage-item-title">${t.name}</div>
              <div class="manage-item-meta">${t.id} â€¢ ${t.type} â€¢ ${t.capacity}L</div>
            </div>
            <div class="manage-item-actions">
              <button class="btn primary" onclick="viewTank('${t.id}')"><i class="fas fa-eye"></i></button>
              <button class="btn" onclick="editTank('${t.id}')"><i class="fas fa-pen"></i></button>
              <button class="btn danger" onclick="deleteTank('${t.id}')"><i class="fas fa-trash"></i></button>
            </div>
          </div>
        `).join('') + '</div>';
      } else if(tab === 'valves') {
        if(valves.length === 0) { content.innerHTML = '<div class="card" style="text-align:center;color:var(--muted)">No valves</div>'; return; }
        
        const { valveTree } = calculateHouseholdStats();
        
        content.innerHTML = '<div class="manage-list">' + valves.map(v => {
          const node = valveTree.get(v.id);
          let householdInfo = `${v.households} HH`;
          
          if(node && v.category === 'main') {
            const subTotal = node.totalHouseholds - node.directHouseholds;
            householdInfo = `Total: ${node.totalHouseholds} HH (${node.directHouseholds} direct + ${subTotal} sub-valves)`;
          }
          
          return `
          <div class="manage-item">
            <div class="manage-item-info">
              <div class="manage-item-title">${v.name}</div>
              <div class="manage-item-meta">${v.id} â€¢ ${v.category.toUpperCase()} â€¢ ${householdInfo}</div>
            </div>
            <div class="manage-item-actions">
              <button class="btn primary" onclick="viewValve('${v.id}')"><i class="fas fa-eye"></i></button>
              <button class="btn" onclick="editValve('${v.id}')"><i class="fas fa-pen"></i></button>
              <button class="btn danger" onclick="deleteValve('${v.id}')"><i class="fas fa-trash"></i></button>
            </div>
          </div>
        `;
        }).join('') + '</div>';
      } else if(tab === 'pipelines') {
        if(pipelines.length === 0) { content.innerHTML = '<div class="card" style="text-align:center;color:var(--muted)">No pipelines</div>'; return; }
        content.innerHTML = '<div class="manage-list">' + pipelines.map(p => `
          <div class="manage-item">
            <div class="manage-item-info">
              <div class="manage-item-title">${p.name}</div>
              <div class="manage-item-meta">${p.type} â€¢ ${p.diameter}mm â€¢ ${p.capacity}L/min</div>
            </div>
            <div class="manage-item-actions">
              <button class="btn primary" onclick="centerPipeline('${p.id}')"><i class="fas fa-crosshairs"></i></button>
              <button class="btn" onclick="editPipeline('${p.id}')"><i class="fas fa-pen"></i></button>
              <button class="btn danger" onclick="deletePipeline('${p.id}')"><i class="fas fa-trash"></i></button>
            </div>
          </div>
        `).join('') + '</div>';
      } else if(tab === 'data') {
        const { stats } = calculateHouseholdStats();
        content.innerHTML = `
          <div class="card">
            <h4><i class="fas fa-cloud"></i> FIREBASE STATUS</h4>
            <div class="row"><span class="label">Connection</span><span class="value" style="color:${isFirebaseConnected ? 'var(--success)' : 'var(--danger)'}">${isFirebaseConnected ? 'Connected' : 'Disconnected'}</span></div>
          </div>
          <div class="household-stats">
            <h4><i class="fas fa-home"></i> HOUSEHOLD STATISTICS</h4>
            <div class="stat-big">
              <div class="stat-big-number">${stats.servedHouseholds}</div>
              <div class="stat-big-label">Households Currently Served</div>
            </div>
            <div class="stat-row">
              <span class="label">Total Households</span>
              <span class="value">${stats.totalHouseholds}</span>
            </div>
            <div class="stat-row">
              <span class="label">Main Valves</span>
              <span class="value">${stats.mainValves.length}</span>
            </div>
            <div class="stat-row">
              <span class="label">Coverage</span>
              <span class="value">${stats.totalHouseholds > 0 ? ((stats.servedHouseholds / stats.totalHouseholds) * 100).toFixed(1) : 0}%</span>
            </div>
            <div class="stat-row">
              <span class="label">Total Supply Flow</span>
              <span class="value">${stats.totalSupplyFlow.toFixed(0)} L/min</span>
            </div>
            <div class="stat-row">
              <span class="label">Avg Supply/HH</span>
              <span class="value">${stats.averageSupplyPerHousehold.toFixed(1)} L/min</span>
            </div>
          </div>
          <div class="card">
            <h4><i class="fas fa-file-export"></i> EXPORT DATA</h4>
            <button class="btn success" onclick="exportData()"><i class="fas fa-download"></i> Export JSON</button>
          </div>
          <div class="card">
            <h4><i class="fas fa-file-import"></i> IMPORT DATA</h4>
            <button class="btn primary" onclick="document.getElementById('importFile').click()"><i class="fas fa-upload"></i> Import JSON</button>
          </div>
          <div class="card">
            <h4><i class="fas fa-info-circle"></i> STATISTICS</h4>
            <div class="row"><span class="label">Tanks</span><span class="value">${tanks.length}</span></div>
            <div class="row"><span class="label">Valves</span><span class="value">${valves.length}</span></div>
            <div class="row"><span class="label">Pipelines</span><span class="value">${pipelines.length}</span></div>
            <div class="row"><span class="label">Total capacity</span><span class="value">${tanks.reduce((sum, t) => sum + t.capacity, 0).toLocaleString()} L</span></div>
          </div>
        `;
      }
    }

    function viewDevice(id, type) {
      const device = type === 'tank' ? tanks.find(t => t.id === id) : valves.find(v => v.id === id);
      if(device) {
        closeModal('manageModal');
        map.setView([device.lat, device.lng], 17);
        showDevice(device, type);
      }
    }
    function viewTank(id) { viewDevice(id, 'tank'); }
    function viewValve(id) { viewDevice(id, 'valve'); }

    // ==================== IMPORT/EXPORT ====================
    async function exportData() {
      const data = {
        tanks: tanks.map(t => t.toFirebase()),
        valves: valves.map(v => v.toFirebase()),
        pipelines: pipelines.map(p => p.toFirebase()),
        version: '3.0-optimized',
        timestamp: Date.now(),
        exportDate: new Date().toISOString()
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `water-system-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
      toast('âœ“ Data exported');
    }

    async function importData(e) {
      const file = e.target.files[0];
      if(!file) return;
      showLoading(true);
      const reader = new FileReader();
      reader.onload = async () => {
        try {
          const data = JSON.parse(reader.result);
          if(data.tanks && Array.isArray(data.tanks)) {
            for(const tankData of data.tanks) { const tank = new Tank(tankData); await FirebaseService.saveTank(tank); }
          }
          if(data.valves && Array.isArray(data.valves)) {
            for(const valveData of data.valves) { const valve = new Valve(valveData); await FirebaseService.saveValve(valve); }
          }
          if(data.pipelines && Array.isArray(data.pipelines)) {
            for(const pipelineData of data.pipelines) { const pipeline = new Pipeline(pipelineData); await FirebaseService.savePipeline(pipeline); }
          }
          showLoading(false);
          flowCacheDirty = true;
          requestDrawCanvas();
          requestSupplyDashboardUpdate();
          toast('âœ“ Data imported');
          if(document.getElementById('manageModal').classList.contains('active')) renderManage('data');
        } catch(error) {
          console.error('Import error:', error);
          showLoading(false);
          toast('âš ï¸ Invalid JSON file');
        }
      };
      reader.readAsText(file);
      e.target.value = '';
    }








    // ==================== HISTORY ====================
    let currentHistoryDevice = null;
    let currentHistoryType = null;
    let currentHistoryData = [];

    function updateHistoryDeviceCard(device, telemetry) {
      const card = document.getElementById('historyDeviceCard');
      if(!card) return;
      if(!telemetry) {
        card.style.display = 'none';
        return;
      }

      const readableTimestamp = telemetry.timestamp ? new Date(telemetry.timestamp).toLocaleString() : 'â€”';
      const distanceRaw = telemetry.distance_meters ?? telemetry.distanceMeters ?? telemetry.distance ?? null;
      const distanceValue = Number(distanceRaw);
      const readingsValue = telemetry.reading_count ?? telemetry.readingCount ?? telemetry.readings ?? null;

      card.style.display = 'block';
      setText('historyDeviceId', telemetry.id || device.id || 'â€”');
      setText('historyDeviceLastUpdate', readableTimestamp);
      setText('historyDeviceDistance', Number.isFinite(distanceValue) ? `${distanceValue.toFixed(2)} m` : 'â€”');
      setText('historyDeviceReadings', readingsValue ?? 'â€”');
    }

    async function openHistory(deviceId, deviceType) {
      currentHistoryDevice = deviceId;
      currentHistoryType = deviceType;
      
      const device = deviceType === 'tanks' ? 
        tanks.find(t => t.id === deviceId) : 
        valves.find(v => v.id === deviceId);
      
      if(!device) return;
      
      openModal('historyModal');
      setText('historyModalTitle', `${device.name} - History`);

      const analyticsEntry = deviceType === 'tanks'
        ? analyticsState?.tanks?.[device.id]
        : analyticsState?.valves?.[device.id];
      const fallbackTelemetry = analyticsEntry?.device || resolveDeviceTelemetry(device);
      updateHistoryDeviceCard(device, fallbackTelemetry);
      
      // Set default date range (last 365 days to catch all data)
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - 365);
      
      document.getElementById('historyStartDate').valueAsDate = startDate;
      document.getElementById('historyEndDate').valueAsDate = endDate;
      
      // First try to load existing history
      await loadHistory();
      
      // If no history data found, automatically sync from device data
      if (currentHistoryData.length === 0) {
        console.log('ðŸ“­ No history data found, automatically syncing from device data...');
        toast('ðŸ”„ Syncing device data to history...');
        
        try {
          // Fetch all device data directly from Firebase
          const allDeviceData = await FirebaseService.fetchAllDeviceData();
          
          if (Object.keys(allDeviceData).length === 0) {
            console.log('ðŸ“­ No device data found in Firebase');
            toast('âš ï¸ No device data found');
            return;
          }
          
          const skipPaths = ['tanks', 'valves', 'pipelines', 'analytics', 'ultrasonic', 'history'];
          let totalSynced = 0;
          
          // Find the tank being viewed and its linked device
          const currentTank = tanks.find(t => t.id === currentHistoryDevice);
          if (!currentTank || !currentTank.deviceId) {
            console.log('âš ï¸ Current tank not found or has no device ID');
            toast('âš ï¸ Tank has no linked device');
            return;
          }
          
          const targetDeviceId = currentTank.deviceId.toUpperCase();
          console.log(`ðŸ” Looking for device data: ${targetDeviceId} for tank: ${currentHistoryDevice}`);
          
          // Process each device
          for (const deviceId of Object.keys(allDeviceData)) {
            if (skipPaths.includes(deviceId)) continue;
            
            // Check if this device matches the tank's device ID
            if (deviceId.toUpperCase() !== targetDeviceId) continue;
            
            const deviceNode = allDeviceData[deviceId];
            if (!deviceNode || typeof deviceNode !== 'object') continue;
            
            // Extract all readings from this device
            const allReadings = FirebaseService.extractAllReadings(deviceNode);
            
            if (allReadings.length > 0) {
              console.log(`ðŸ”„ Auto-syncing ${allReadings.length} readings for device ${deviceId} â†’ tank ${currentTank.id} (${currentTank.name})`);
              console.log(`   Tank dimensions: ${currentTank.shape}, Height: ${currentTank.height}m, Sensor: ${currentTank.sensorHeight || currentTank.height}m`);
              
              // Sync with tank object for calculations
              const result = await HistoryService.syncDeviceReadingsToHistory(currentTank.id, 'tanks', allReadings, currentTank);
              totalSynced += result.synced || 0;
              
              if (result.synced > 0) {
                console.log(`âœ… Synced ${result.synced} readings for ${currentTank.id}`);
              }
              if (result.skipped > 0) {
                console.log(`â­ï¸ Skipped ${result.skipped} duplicates`);
              }
            } else {
              console.log(`âš ï¸ No readings found for device ${deviceId}`);
            }
          }
          
          if (totalSynced > 0) {
            console.log(`âœ… Auto-sync complete! Synced ${totalSynced} total readings.`);
            toast(`âœ… Synced ${totalSynced} readings!`);
            
            // Wait a moment for Firebase to process writes, then reload history
            setTimeout(async () => {
              console.log('ðŸ”„ Reloading history after sync...');
              await loadHistory();
            }, 1000);
          } else {
            console.log('âš ï¸ No readings synced. Check if device is linked to tank.');
            toast('âš ï¸ No device data to sync');
          }
        } catch (error) {
          console.error('âŒ Error in auto-sync:', error);
          toast('âŒ Error syncing device data');
        }
      }
    }

    async function loadHistory() {
  const startDate = document.getElementById('historyStartDate').value;
  const endDate = document.getElementById('historyEndDate').value;
  const timeRange = document.getElementById('historyTimeRange').value;
  
  const historyContent = document.getElementById('historyContent');
  historyContent.innerHTML = `
    <div style="text-align: center; padding: 40px; color: var(--muted);">
      <i class="fas fa-spinner fa-spin" style="font-size: 32px;"></i>
      <div style="margin-top: 12px;">Loading history...</div>
    </div>
  `;
  
  console.log(`ðŸ” Loading history for ${currentHistoryType}/${currentHistoryDevice}`);
  console.log(`ðŸ“… Date range: ${startDate || 'none'} to ${endDate || 'none'}`);
  
  currentHistoryData = await HistoryService.getHistory(
    currentHistoryDevice, 
    currentHistoryType,
    startDate && startDate.trim() ? startDate : null,
    endDate && endDate.trim() ? endDate : null
  );
  
  console.log(`ðŸ“Š Retrieved ${currentHistoryData.length} history entries`);
  
  // Apply time range filter if selected
  if(timeRange) {
    const [startHour, endHour] = timeRange.split('-').map(Number);
    const beforeFilter = currentHistoryData.length;
    currentHistoryData = currentHistoryData.filter(h => {
      const hour = new Date(h.timestamp).getHours();
      return hour >= startHour && hour < endHour;
    });
    console.log(`â° After time range filter (${startHour}-${endHour}): ${beforeFilter} â†’ ${currentHistoryData.length}`);
  }
  
  renderHistory(currentHistoryData);
}

    function renderHistory(history) {
  const historyContent = document.getElementById('historyContent');
  
  // Helper function for safe number formatting
  const safeNumber = (value, decimals = 0) => {
    if (value === undefined || value === null || isNaN(value) || !isFinite(value)) {
      return '-';
    }
    return Number(value).toFixed(decimals);
  };
  
  if(history.length === 0) {
    historyContent.innerHTML = `
      <div style="text-align: center; padding: 40px; color: var(--muted);">
        <i class="fas fa-inbox" style="font-size: 32px;"></i>
        <div style="margin-top: 12px;">No history data available for this date range</div>
      </div>
    `;
    return;
  }
  
  
  let tableHTML = ''; // IMPORTANT: Initialize variable
  
  if(currentHistoryType === 'tanks') {
    // Check if we have device readings (distance-based) or tank analytics
    const hasDeviceReadings = history.some(h => h.distance !== undefined);
    const hasTankAnalytics = history.some(h => h.currentVolume !== undefined);
    
    if (hasDeviceReadings && !hasTankAnalytics) {
      // Show device readings table with calculated metrics
      const hasCalculatedMetrics = history.some(h => h.waterLevel !== undefined || h.currentVolume !== undefined);
      
      tableHTML = `
        <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
          <thead>
            <tr style="background: #fafbfc; border-bottom: 2px solid var(--line);">
              <th style="padding: 12px; text-align: left; font-weight: 700;">Date</th>
              <th style="padding: 12px; text-align: left; font-weight: 700;">Time</th>
              <th style="padding: 12px; text-align: center;">Distance (m)</th>
              <th style="padding: 12px; text-align: center;">Distance (cm)</th>
              ${hasCalculatedMetrics ? '<th style="padding: 12px; text-align: center;">Water Level (m)</th>' : ''}
              ${hasCalculatedMetrics ? '<th style="padding: 12px; text-align: center;">Volume (L)</th>' : ''}
            </tr>
          </thead>
          <tbody>
            ${history.map((h, idx) => {
              const dateObj = new Date(h.timestamp);
              const dateStr = dateObj.toLocaleDateString('en-IN');
              const timeStr = dateObj.toLocaleTimeString('en-IN');
              
              return `
              <tr style="border-bottom: 1px solid #f2f4f7; ${idx % 2 === 0 ? 'background: #fafbfc;' : ''}">
                <td style="padding: 10px; white-space: nowrap; font-weight: 600;">${dateStr}</td>
                <td style="padding: 10px; white-space: nowrap;">${timeStr}</td>
                <td style="padding: 10px; text-align: center; font-weight: 600; color: #0277bd;">
                  ${safeNumber(h.distance, 3)}
                </td>
                <td style="padding: 10px; text-align: center; font-weight: 600; color: #0277bd;">
                  ${safeNumber(h.distance_cm, 1)}
                </td>
                ${hasCalculatedMetrics ? `
                <td style="padding: 10px; text-align: center; font-weight: 600; color: #4caf50;">
                  ${safeNumber(h.waterLevel, 2)}
                </td>
                <td style="padding: 10px; text-align: center; font-weight: 700; color: #6a1b9a;">
                  ${safeNumber(h.currentVolume, 0)}
                </td>
                ` : ''}
              </tr>
            `;
            }).join('')}
          </tbody>
        </table>
      `;
    } else {
      // Show full tank analytics table (with device readings if available)
      tableHTML = `
        <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
          <thead>
            <tr style="background: #fafbfc; border-bottom: 2px solid var(--line);">
              <th style="padding: 12px; text-align: left; font-weight: 700;">Date</th>
              <th style="padding: 12px; text-align: left; font-weight: 700;">Time</th>
              ${hasDeviceReadings ? '<th style="padding: 12px; text-align: center;">Distance (m)</th>' : ''}
              ${hasDeviceReadings ? '<th style="padding: 12px; text-align: center;">Water Level (m)</th>' : ''}
              <th style="padding: 12px; text-align: center;">Volume (L)</th>
              <th style="padding: 12px; text-align: center;">Main Flow (L/min)</th>
              <th style="padding: 12px; text-align: center;">Households</th>
              <th style="padding: 12px; text-align: center;">Pressure (PSI)</th>
              <th style="padding: 12px; text-align: left;">Valve States</th>
            </tr>
          </thead>
          <tbody>
            ${history.map((h, idx) => {
              const dateObj = new Date(h.timestamp);
              const dateStr = dateObj.toLocaleDateString('en-IN');
              const timeStr = dateObj.toLocaleTimeString('en-IN');
              const valveStatesHTML = h.valveStates ? 
                h.valveStates.map(v => `
                  <div style="font-size: 10px; padding: 2px 0;">
                    <span style="color: ${v.state === 'OPEN' ? '#4caf50' : '#f44336'}; font-weight: 700;">
                      ${v.state === 'OPEN' ? 'â—' : 'â—'}
                    </span>
                    ${v.name}
                  </div>
                `).join('') : 
                '<span style="color: #999;">No data</span>';
              
              return `
              <tr style="border-bottom: 1px solid #f2f4f7; ${idx % 2 === 0 ? 'background: #fafbfc;' : ''}">
                <td style="padding: 10px; white-space: nowrap; font-weight: 600;">${dateStr}</td>
                <td style="padding: 10px; white-space: nowrap;">${timeStr}</td>
                ${hasDeviceReadings ? `<td style="padding: 10px; text-align: center; font-weight: 600; color: #0277bd;">${safeNumber(h.distance, 3)}</td>` : ''}
                ${hasDeviceReadings ? `<td style="padding: 10px; text-align: center; font-weight: 600; color: #4caf50;">${safeNumber(h.waterLevel, 2)}</td>` : ''}
                <td style="padding: 10px; text-align: center; font-weight: 600;">${safeNumber(h.currentVolume, 0)} L</td>
                <td style="padding: 10px; text-align: center; font-weight: 600; color: ${(h.mainFlowRate || 0) > 100 ? '#f44336' : '#4caf50'};">
                  ${safeNumber(h.mainFlowRate, 2)}
                </td>
                <td style="padding: 10px; text-align: center; font-weight: 700; color: #6a1b9a;">
                  ${h.householdSupply || 0}
                </td>
                <td style="padding: 10px; text-align: center; font-weight: 600;">
                  ${safeNumber(h.pressureChange, 1)}
                </td>
                <td style="padding: 10px;">
                  ${valveStatesHTML}
                </td>
              </tr>
            `;
            }).join('')}
          </tbody>
        </table>
      `;
    }
  } else if(currentHistoryType === 'valves') {
    tableHTML = `
      <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
        <thead>
          <tr style="background: #fafbfc; border-bottom: 2px solid var(--line);">
            <th style="padding: 12px; text-align: left; font-weight: 700;">Date & Time</th>
            <th style="padding: 12px; text-align: center;">State</th>
            <th style="padding: 12px; text-align: center;">Supply Flow</th>
            <th style="padding: 12px; text-align: center;">Avg/HH</th>
            <th style="padding: 12px; text-align: center;">Served</th>
            <th style="padding: 12px; text-align: left; min-width: 200px;">Changes</th>
          </tr>
        </thead>
        <tbody>
          ${history.map((h, idx) => `
            <tr style="border-bottom: 1px solid #f2f4f7; ${idx % 2 === 0 ? 'background: #fafbfc;' : ''}">
              <td style="padding: 10px; white-space: nowrap;">${new Date(h.timestamp).toLocaleString()}</td>
              <td style="padding: 10px; text-align: center;">
                <span style="padding: 4px 8px; border-radius: 6px; background: ${h.valveState === 'open' ? '#e9f7ee' : '#fdeaea'}; color: ${h.valveState === 'open' ? 'var(--success)' : 'var(--danger)'}; font-weight: 600; font-size: 11px;">
                  ${(h.valveState || 'unknown').toUpperCase()}
                </span>
              </td>
              <td style="padding: 10px; text-align: center; font-weight: 600; color: ${(h.supplyFlow || 0) > 0 ? '#4caf50' : '#999'};">
                ${h.supplyFlow ? h.supplyFlow.toFixed(0) : '0'} L/min
              </td>
              <td style="padding: 10px; text-align: center; font-weight: 600;">
                ${h.avgSupplyPerHousehold ? h.avgSupplyPerHousehold.toFixed(2) : '0'} L/min
              </td>
              <td style="padding: 10px; text-align: center;">
                <span style="padding: 4px 8px; border-radius: 6px; background: ${(h.householdsServed || 0) > 0 ? '#e9f7ee' : '#fdeaea'}; color: ${(h.householdsServed || 0) > 0 ? 'var(--success)' : 'var(--danger)'}; font-weight: 600; font-size: 11px;">
                  ${h.householdsServed || 0} HH
                </span>
              </td>
              <td style="padding: 10px; font-size: 11px; color: #666;">
                ${h.changes || 'No changes recorded'}
              </td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    `;
  } else {
    // Fallback for unknown type
    tableHTML = `
      <div style="text-align: center; padding: 40px; color: var(--muted);">
        <i class="fas fa-exclamation-triangle" style="font-size: 32px;"></i>
        <div style="margin-top: 12px;">Unknown history type</div>
      </div>
    `;
  }
  
  historyContent.innerHTML = tableHTML;
}


// Function to manually sync all device data to history with calculated metrics
async function syncAllDeviceDataToHistory() {
  console.log('ðŸ”„ Starting manual sync of all device data to history...');
  toast('ðŸ”„ Syncing device data to history with calculations...');
  
  try {
    // Fetch all device data directly from Firebase (one-time fetch)
    console.log('ðŸ“¡ Fetching all device data from Firebase...');
    const allDeviceData = await FirebaseService.fetchAllDeviceData();
    
    if (Object.keys(allDeviceData).length === 0) {
      console.log('âš ï¸ No device data found in Firebase');
      toast('âš ï¸ No device data found in Firebase');
      return;
    }
    
    console.log(`ðŸ“¡ Found ${Object.keys(allDeviceData).length} device(s) in Firebase`);
    
    const skipPaths = ['tanks', 'valves', 'pipelines', 'analytics', 'ultrasonic', 'history'];
    let totalSynced = 0;
    
    // Process each device
    for (const deviceId of Object.keys(allDeviceData)) {
      if (skipPaths.includes(deviceId)) continue;
      
      const deviceNode = allDeviceData[deviceId];
      if (!deviceNode || typeof deviceNode !== 'object') continue;
      
      // Extract all readings from this device
      const allReadings = FirebaseService.extractAllReadings(deviceNode);
      
      if (allReadings.length > 0) {
        // Find which tank is linked to this device
        const linkedTank = tanks.find(t => t.deviceId && t.deviceId.toUpperCase() === deviceId.toUpperCase());
        
        if (linkedTank) {
          console.log(`ðŸ“ Syncing ${allReadings.length} readings for device ${deviceId} â†’ tank ${linkedTank.id} (${linkedTank.name})`);
          console.log(`   Tank dimensions: ${linkedTank.shape}, Height: ${linkedTank.height}m, Sensor: ${linkedTank.sensorHeight || linkedTank.height}m`);
          
          // Sync with tank object for calculations
          await HistoryService.syncDeviceReadingsToHistory(linkedTank.id, 'tanks', allReadings, linkedTank);
          totalSynced += allReadings.length;
        } else {
          console.log(`âš ï¸ Device ${deviceId} is not linked to any tank`);
        }
      }
    }
    
    console.log(`âœ… Sync complete! Synced ${totalSynced} total readings with calculated metrics.`);
    toast(`âœ… Synced ${totalSynced} readings with calculations to history!`);
    
    // Reload history if modal is open
    if (currentHistoryDevice && currentHistoryType) {
      await loadHistory();
    }
  } catch (error) {
    console.error('âŒ Error syncing device data:', error);
    toast('âŒ Error syncing device data');
  }
}

// Make it available globally for console access
window.syncAllDeviceDataToHistory = syncAllDeviceDataToHistory;

// TEMPORARY DEBUG FUNCTION - Remove after testing
async function debugHistory() {
  console.log('ðŸ” Debug: Current History Device:', currentHistoryDevice);
  console.log('ðŸ” Debug: Current History Type:', currentHistoryType);
  console.log('ðŸ” Debug: Current History Data:', currentHistoryData);
  
  if (currentHistoryDevice && currentHistoryType) {
    const testData = await HistoryService.getHistory(
      currentHistoryDevice,
      currentHistoryType,
      null,
      null
    );
    console.log('ðŸ” Debug: Fetched History from Firebase:', testData);
  }
}

    function exportCurrentHistory() {
      if(!currentHistoryDevice || !currentHistoryData) return;
      
      const device = currentHistoryType === 'tanks' ? 
        tanks.find(t => t.id === currentHistoryDevice) : 
        valves.find(v => v.id === currentHistoryDevice);
      
      if(!device) return;
      
      HistoryService.exportToCSV(currentHistoryData, device.name, currentHistoryType);
    }

    // ==================== HELPER FUNCTIONS ====================

// Convert ESP32 millis timestamp to real datetime
function convertDeviceTimestamp(deviceMillis) {
  if (!deviceMillis) return null;
  
  // Device sends millis since boot, we need to calculate actual time
  // Assume we store the server time when device first connected
  const now = Date.now();
  const estimatedBootTime = now - deviceMillis;
  return new Date(estimatedBootTime + deviceMillis);
}

// Get real timestamp from device data
function getRealTimestamp(deviceTelemetry) {
  if (!deviceTelemetry) return null;
  
  const deviceMillis = deviceTelemetry.timestamp;
  if (!deviceMillis) return null;
  
  // Calculate real time: current time - (device uptime)
  const now = Date.now();
  const deviceUptime = deviceMillis;
  const estimatedRealTime = now - (Date.now() - deviceUptime);
  
  return new Date(estimatedRealTime);
}

// Calculate ETA for tank depletion with proper datetime
function calculateTankETAWithTime(tank, currentFlow) {
  const currentVolume = tank.calculateCurrentVolume();
  const maxCapacity = tank.calculateMaxCapacity();
  const fillPercent = (currentVolume / maxCapacity) * 100;
  
  let status = 'good';
  let statusColor = '#4caf50';
  let timeToEmpty = 0;
  let etaDate = null;
  let etaFormatted = 'â€”';
  
  if (currentFlow > 0) {
    timeToEmpty = currentVolume / currentFlow; // minutes
    const now = new Date();
    etaDate = new Date(now.getTime() + timeToEmpty * 60000);
    
    // Format ETA
    const today = new Date();
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    if (etaDate.toDateString() === today.toDateString()) {
      etaFormatted = `Today at ${etaDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })}`;
    } else if (etaDate.toDateString() === tomorrow.toDateString()) {
      etaFormatted = `Tomorrow at ${etaDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })}`;
    } else {
      etaFormatted = etaDate.toLocaleString('en-US', { 
        month: 'short', 
        day: 'numeric', 
        hour: '2-digit', 
        minute: '2-digit' 
      });
    }
    
    // Status logic
    if (timeToEmpty < 60) { // Less than 1 hour
      status = 'critical';
      statusColor = '#f44336';
    } else if (timeToEmpty < 240) { // Less than 4 hours
      status = 'warning';
      statusColor = '#ff9800';
    }
  } else {
    status = 'no_flow';
    statusColor = '#2196f3';
  }
  
  return {
    status,
    statusColor,
    currentVolume,
    maxCapacity,
    fillPercent,
    currentFlow,
    timeToEmpty,
    etaDate,
    etaFormatted,
    timeFormatted: formatTime(timeToEmpty)
  };
}

// Format time in human readable format
function formatTime(minutes) {
  if (minutes === 0) return 'â€”';
  
  const hours = Math.floor(minutes / 60);
  const mins = Math.floor(minutes % 60);
  const days = Math.floor(hours / 24);
  const remainingHours = hours % 24;
  
  if (days > 0) {
    return `${days}d ${remainingHours}h ${mins}m`;
  } else if (hours > 0) {
    return `${hours}h ${mins}m`;
  } else {
    return `${mins}m`;
  }
}

// Recursive function to get all sub-valves (multi-level)
function getAllSubValvesRecursive(mainValveId, allValves) {
  const directSubs = allValves.filter(v => v.parentValveId === mainValveId);
  let allSubs = [...directSubs];
  
  // Recursively get sub-valves of sub-valves
  directSubs.forEach(subValve => {
    const nestedSubs = getAllSubValvesRecursive(subValve.id, allValves);
    allSubs = [...allSubs, ...nestedSubs];
  });
  
  return allSubs;
}

// Calculate total households including all nested sub-valves
function calculateTotalHouseholds(valve, allValves) {
  let total = valve.households || 0;
  
  const allSubValves = getAllSubValvesRecursive(valve.id, allValves);
  allSubValves.forEach(sv => {
    total += sv.households || 0;
  });
  
  return total;
}

// Calculate currently served households (only open valves)
function calculateServedHouseholds(valve, allValves) {
  let served = 0;
  
  // If main valve is closed, nobody gets water
  if (valve.active) return 0;
  
  // Add direct households if valve is open
  served += valve.households || 0;
  
  // Recursively check sub-valves
  const directSubs = allValves.filter(v => v.parentValveId === valve.id);
  directSubs.forEach(subValve => {
    if (!subValve.active) {
      served += calculateServedHouseholds(subValve, allValves);
    }
  });
  
  return served;
}

// Search valves by ID or name
function searchValves(query, allValves) {
  if (!query) return [];
  
  const lowerQuery = query.toLowerCase();
  return allValves.filter(v => 
    v.id.toLowerCase().includes(lowerQuery) || 
    v.name.toLowerCase().includes(lowerQuery)
  );
}

// ==================== MAIN SHOWDEVICE FUNCTION ====================

async function showDevice(device, type) {
  document.getElementById('supplyDashboard').classList.add('shifted');

  const sidebar = document.getElementById('sidebar');
  const body = document.getElementById('sidebarBody');
  currentSidebarDeviceId = device?.id || null;
  currentSidebarDeviceType = type || null;
  
  if(type === 'tank') {
    const info = device.info();
    const connectedPipelines = findConnectedPipelines(device);
    const analyticsTank = analyticsState?.tanks?.[device.id] || null;
    const deviceTelemetry = analyticsTank?.device || resolveDeviceTelemetry(device);
    const householdsData = analyticsTank?.households || null;
    
    // Get real distance from device (ESP32 sends "distance" field)
    const telemetryDistance = deviceTelemetry?.distance ?? deviceTelemetry?.distance_meters ?? deviceTelemetry?.distanceMeters ?? null;
    
    // Calculate water level from distance if available
    let displayWaterLevel = device.waterLevel;
    if (telemetryDistance !== null && telemetryDistance !== undefined && device.deviceId) {
      displayWaterLevel = device.calculateWaterLevelFromDistance(telemetryDistance);
      // Update tank water level if it changed significantly
      if (Math.abs(device.waterLevel - displayWaterLevel) > 0.01) {
        device.setWaterLevel(displayWaterLevel);
      }
    }
    
    // Fix timestamp - convert from millis to real datetime
    let deviceTimestamp = 'â€”';
    let deviceTimestampRaw = null;
    if (deviceTelemetry?.timestamp) {
      // ESP32 sends millis since boot, calculate real time
      const now = Date.now();
      const deviceMillis = deviceTelemetry.timestamp;
      
      // Estimate device boot time (assuming data is recent)
      // In production, you should store boot time in Firebase
      const estimatedBootTime = now - deviceMillis;
      const realTime = new Date(estimatedBootTime + deviceMillis);
      
      deviceTimestampRaw = realTime;
      deviceTimestamp = realTime.toLocaleString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: true
      });
      
      // Calculate time ago
      const secondsAgo = Math.floor((now - realTime.getTime()) / 1000);
      if (secondsAgo < 60) {
        deviceTimestamp += ` (${secondsAgo}s ago)`;
      } else if (secondsAgo < 3600) {
        deviceTimestamp += ` (${Math.floor(secondsAgo / 60)}m ago)`;
      } else {
        deviceTimestamp += ` (${Math.floor(secondsAgo / 3600)}h ago)`;
      }
    }
    
    // Calculate current outflow from connected main valves
    let totalOutflow = 0;
    if (device.connectedMainValves && device.connectedMainValves.length > 0) {
      const connectedValves = valves.filter(v => 
        device.connectedMainValves.includes(v.id) && v.category === 'main'
      );
      
      connectedValves.forEach(valve => {
        if (!valve.active) {
          totalOutflow += valve.flowRate || 0;
          
          // Add sub-valve flows recursively
          const allSubs = getAllSubValvesRecursive(valve.id, valves);
          allSubs.forEach(sv => {
            if (!sv.active) totalOutflow += (sv.flowRate || 0);
          });
        }
      });
    }
    
    // Calculate ETA with proper datetime
    const etaData = calculateTankETAWithTime(device, totalOutflow);
    
    // Calculate total households served
    let totalHouseholdsServed = 0;
    if (device.connectedMainValves && device.connectedMainValves.length > 0) {
      const connectedValves = valves.filter(v => 
        device.connectedMainValves.includes(v.id) && v.category === 'main'
      );
      
      connectedValves.forEach(valve => {
        totalHouseholdsServed += calculateServedHouseholds(valve, valves);
      });
    }
    
    // Live metrics display
    const liveMetrics = {
      distance: telemetryDistance !== null ? `${(telemetryDistance * 100).toFixed(1)} cm` : 'â€”',
      waterLevel: `${displayWaterLevel.toFixed(2)} m`,
      timestamp: deviceTimestamp
    };
    
    setText('sidebarTitle', `ðŸ—ï¸ ${device.name}`);
    body.innerHTML = `
      <div class="card">
            <h4><i class="fas fa-info-circle"></i> DETAILS</h4>
            <div class="row"><span class="label">ID</span><span class="value">${info.id}</span></div>
            <div class="row"><span class="label">Type</span><span class="value">${info.type}</span></div>
            <div class="row"><span class="label">Capacity</span><span class="value">${info.capacity}</span></div>
            <div class="row"><span class="label">Status</span><span class="value" style="color:var(--success)">${info.status.toUpperCase()}</span></div>
          </div>
          ${device.deviceId ? `
          <div class="card" style="background: linear-gradient(135deg, #0288d1 0%, #0277bd 100%); color: #fff; border: none;">
            <h4 style="color: #fff; margin: 0 0 12px 0;"><i class="fas fa-satellite-dish"></i> LIVE DEVICE DATA</h4>
            <div class="row" style="background: rgba(255,255,255,0.15); padding: 10px; border-radius: 8px; margin: 8px 0;">
              <span class="label" style="color: rgba(255,255,255,0.9);">Device ID</span>
              <span class="value" style="color: #fff; font-weight: 700;">${device.deviceId}</span>
            </div>
            ${deviceTelemetry ? `
            <div class="row" style="background: rgba(255,255,255,0.15); padding: 10px; border-radius: 8px; margin: 8px 0;">
              <span class="label" style="color: rgba(255,255,255,0.9);">Distance (Sensor to Water)</span>
              <span class="value" style="color: #fff; font-weight: 700; font-size: 18px;">${liveMetrics.distance}</span>
            </div>
            <div class="row" style="background: rgba(255,255,255,0.15); padding: 10px; border-radius: 8px; margin: 8px 0;">
              <span class="label" style="color: rgba(255,255,255,0.9);">Calculated Water Level</span>
              <span class="value" style="color: #fff; font-weight: 700; font-size: 18px;">${liveMetrics.waterLevel}</span>
            </div>
            <div class="row" style="background: rgba(255,255,255,0.15); padding: 10px; border-radius: 8px; margin: 8px 0;">
              <span class="label" style="color: rgba(255,255,255,0.9);">Last Update</span>
              <span class="value" style="color: #fff;">${liveMetrics.timestamp}</span>
            </div>
            ` : `
            <div class="row" style="background: rgba(255,193,7,0.2); padding: 10px; border-radius: 8px; margin: 8px 0; border: 1px solid rgba(255,193,7,0.5);">
              <span class="label" style="color: rgba(255,255,255,0.9);"><i class="fas fa-clock"></i> Status</span>
              <span class="value" style="color: #ffc107; font-weight: 600;">Waiting for device data...</span>
            </div>
            <div style="font-size: 11px; color: rgba(255,255,255,0.7); margin-top: 8px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px;">
              <i class="fas fa-info-circle"></i> Device ID "${device.deviceId}" is linked, but no telemetry data found in Firebase. 
              Ensure your ESP32 device is posting to <code>/ultrasonic/${device.deviceId}</code>
            </div>
            `}
          </div>
          ` : `
          <div class="card" style="background: #fff3cd; border: 2px solid #ffc107;">
            <h4 style="color: #856404;"><i class="fas fa-exclamation-triangle"></i> NO DEVICE LINKED</h4>
            <p style="color: #856404; margin: 8px 0;">This tank is not connected to a device. Edit the tank to add a Device ID.</p>
            <button class="btn primary" onclick="editTank('${device.id}')" style="margin-top: 8px;">
              <i class="fas fa-link"></i> Link Device
            </button>
          </div>
          `}
          <div class="water-level-container">
            <h4 style="margin:0 0 12px 0;font-size:13px;font-weight:700;color:#0277bd">
              <i class="fas fa-water"></i> WATER LEVEL ${device.deviceId ? '(AUTO FROM DEVICE)' : '(MANUAL)'}
            </h4>
            <div class="water-tank-visual">
<div class="water-fill" id="waterFill" style="height:${(displayWaterLevel / device.height) * 100}%">                ${displayWaterLevel.toFixed(2)} m
              </div>
            </div>
           <input type="range" class="water-level-slider" id="waterLevelSlider" 
                   min="0" max="${device.height}" step="0.1" value="${displayWaterLevel}" ${device.deviceId ? 'disabled title="Water level is automatically updated from device"' : ''}/>
            <div style="text-align:center;margin-top:8px;font-size:13px;color:#0277bd;font-weight:600">
              ${device.deviceId ? 'Auto-updated from device' : 'Adjust water level'}: <span id="waterLevelDisplay">${displayWaterLevel.toFixed(2)} m</span>
            </div>
          </div>
          <div class="card" style="background: linear-gradient(135deg, ${(etaData.statusColor || '#4caf50')}15, ${(etaData.statusColor || '#4caf50')}05); border: 2px solid ${(etaData.statusColor || '#4caf50')};">
            <h4 style="color: ${etaData.statusColor || '#4caf50'};"><i class="fas fa-clock"></i> WATER DEPLETION FORECAST</h4>
            ${etaData.status === 'not_configured' ? `
              <div style="text-align: center; padding: 20px;">
                <i class="fas fa-cog" style="font-size: 32px; color: #999; margin-bottom: 8px;"></i>
                <div style="font-size: 14px; color: #666; font-weight: 600;">${etaData.message}</div>
                <button class="btn primary" onclick="editTank('${device.id}')" style="margin-top: 12px;">
                  <i class="fas fa-link"></i> Connect Main Valves
                </button>
              </div>
            ` : `
              <div class="row" style="background: rgba(255,255,255,0.5); padding: 12px; border-radius: 8px; margin: 8px 0;">
                <span class="label" style="font-weight: 700;">Status</span>
                <span class="value" style="color: ${etaData.statusColor}; font-weight: 700; text-transform: uppercase;">
                  ${etaData.status === 'critical' ? 'ðŸ”´ CRITICAL' : 
                    etaData.status === 'warning' ? 'âš ï¸ WARNING' : 
                    etaData.status === 'no_flow' ? 'â¸ï¸ NO FLOW' : 'âœ… GOOD'}
                </span>
              </div>
              <div class="row">
                <span class="label">Current Volume:</span>
                <span class="tooltip-value" style="color: #03a9f4; font-size: 16px;">
                  ${parseInt(etaData.currentVolume || 0).toLocaleString()} L
                </span>
              </div>
              <div class="row">
                <span class="label">Max Capacity:</span>
                <span class="tooltip-value">
                  ${parseInt(device.calculateMaxCapacity()).toLocaleString()} L
                </span>
              </div>
              <div class="row">
                <span class="label">Fill Percentage:</span>
                <span class="tooltip-value" style="color: ${(etaData.fillPercent || 0) > 70 ? '#4caf50' : '#ff9800'};">
                  ${(etaData.fillPercent || 0).toFixed(1)}%
                </span>
              </div>
              <div class="row">
                <span class="label">Water Level</span>
                <span class="value">${device.waterLevel} m</span>
              </div>
              <div style="background: rgba(255,255,255,0.3); padding: 12px; border-radius: 8px; margin: 12px 0;">
                <div style="font-weight: 700; margin-bottom: 10px; font-size: 12px;">
                  <i class="fas fa-tint"></i> MAIN WATER OUTFLOW
                </div>
                <div class="row" style="margin: 4px 0;">
                  <span class="label">Flow Rate</span>
                  <span class="value" style="color: ${etaData.currentFlow > 0 ? '#4caf50' : '#999'}; font-weight: 700; font-size: 18px;">
                    ${etaData.currentFlow.toFixed(1)} L/min
                  </span>
                </div>
                <div class="row" style="margin: 4px 0;">
                  <span class="label">Time to Empty</span>
                  <span class="value" style="font-size: 16px; font-weight: 700; color: ${etaData.statusColor};">
                    ${etaData.currentTimeFormatted}
                  </span>
                </div>
                ${etaData.currentFlow > 0 ? `
                <div class="row" style="margin: 4px 0;">
                  <span class="label">Empty By (ETA)</span>
                  <span class="value" style="font-weight: 700; font-size: 11px;">
                    ${etaData.currentETAFormatted}
                  </span>
                </div>
                ` : ''}
              </div>
              <div class="row" style="background: rgba(255,255,255,0.3); padding: 10px; border-radius: 8px;">
                <span class="label">Households Supplied</span>
                <span class="value" style="color: #6a1b9a; font-weight: 700;">
                  ${(householdsData?.served ?? etaData.totalHouseholdsServed) || 0} HH
                </span>
              </div>
              ${etaData.status === 'critical' ? `
                <div style="background: #ffebee; border: 2px solid #f44336; border-radius: 8px; padding: 12px; margin-top: 12px;">
                  <div style="color: #c62828; font-weight: 700; font-size: 13px; text-align: center;">
                    <i class="fas fa-exclamation-triangle"></i> CRITICAL: Tank will be empty in ${etaData.currentTimeFormatted}!
                  </div>
                </div>
              ` : ''}
            `}
          </div>


          <div class="card">
            <h4><i class="fas fa-map-marker-alt"></i> LOCATION</h4>
            <div class="row"><span class="label">State</span><span class="value">${info.loc.state}</span></div>
            <div class="row"><span class="label">District</span><span class="value">${info.loc.district}</span></div>
            <div class="row"><span class="label">Mandal</span><span class="value">${info.loc.mandal}</span></div>
            <div class="row"><span class="label">Habitation</span><span class="value">${info.loc.habitation}</span></div>
            <div class="row"><span class="label">Coordinates</span><span class="value">${info.loc.coords}</span></div>
            <button class="btn primary" onclick="map.setView([${device.lat},${device.lng}],18)"><i class="fas fa-crosshairs"></i> Center on Map</button>
          </div>
          


          <div class="card">
            <h4><i class="fas fa-valve"></i> CONNECTED MAIN VALVES CONTROL</h4>
            ${(() => {
              if (!device.connectedMainValves || device.connectedMainValves.length === 0) {
                return `
                  <div style="text-align: center; padding: 20px; color: var(--muted);">
                    <i class="fas fa-unlink" style="font-size: 24px; margin-bottom: 8px;"></i>
                    <div style="font-size: 13px;">No main valves connected</div>
                    <button class="btn primary" onclick="editTank('${device.id}')" style="margin-top: 12px;">
                      <i class="fas fa-link"></i> Connect Main Valves
                    </button>
                  </div>
                `;
              }
              
              const connectedValves = valves.filter(v => 
                device.connectedMainValves.includes(v.id) && v.category === 'main'
              );
              
              if (connectedValves.length === 0) {
                return `
                  <div style="text-align: center; padding: 20px; color: var(--muted);">
                    <i class="fas fa-exclamation-triangle" style="font-size: 24px; margin-bottom: 8px;"></i>
                    <div style="font-size: 13px;">Connected valves not found in system</div>
                  </div>
                `;
              }
              
              let totalOutflow = 0;
              const valveControls = connectedValves.map(valve => {
                const subValves = valves.filter(v => v.category === 'sub' && v.parentValveId === valve.id);
                let valveOutflow = 0;
                
                if (!valve.active) {
                  valveOutflow = valve.flowRate || 0;
                  subValves.forEach(sv => {
                    if (!sv.active) valveOutflow += (sv.flowRate || 0);
                  });
                }
                
                totalOutflow += valveOutflow;
                
                return `
                  <div style="background: ${valve.active ? '#ffebee' : '#e8f5e9'}; 
                              border: 2px solid ${valve.active ? '#f44336' : '#4caf50'}; 
                              border-radius: 10px; 
                              padding: 14px; 
                              margin-bottom: 12px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                      <div style="flex: 1;">
                        <div style="font-weight: 700; font-size: 14px; color: #333;">
                          <i class="fas fa-cog"></i> ${valve.name}
                        </div>
                        <div style="font-size: 11px; color: #666; margin-top: 4px;">
                          ${valve.households} households â€¢ ${valve.mandal}
                        </div>
                      </div>
                      <div style="text-align: right;">
                        <div style="font-size: 18px; font-weight: 700; color: ${valve.active ? '#f44336' : '#4caf50'};">
                          ${valveOutflow.toFixed(1)} L/min
                        </div>
                        <div style="font-size: 10px; color: ${valve.active ? '#f44336' : '#4caf50'}; font-weight: 600;">
                          ${valve.active ? 'ðŸ”´ CLOSED' : 'âœ… OPEN'}
                        </div>
                      </div>
                    </div>
                    
                    ${subValves.length > 0 ? `
                      <div style="background: rgba(255,255,255,0.5); border-radius: 6px; padding: 8px; margin-bottom: 10px;">
                        <div style="font-size: 11px; font-weight: 600; color: #666; margin-bottom: 6px;">
                          Sub-Valves (${subValves.filter(sv => !sv.active).length}/${subValves.length} open)
                        </div>
                        ${subValves.map(sv => `
                          <div style="font-size: 10px; color: #666; padding: 2px 0;">
                            <span style="color: ${sv.active ? '#f44336' : '#4caf50'};">
                              ${sv.active ? 'â—' : 'â—‹'}
                            </span>
                            ${sv.name} (${sv.households} HH, ${sv.flowRate || 0} L/min)
                          </div>
                        `).join('')}
                      </div>
                    ` : ''}
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                      <button class="btn success" 
                              onclick="setValveFlow('${valve.id}', false)" 
                              ${!valve.active ? 'disabled' : ''}
                              style="margin: 0; padding: 8px; font-size: 12px;">
                        <i class="fas fa-check"></i> Open
                      </button>
                      <button class="btn danger" 
                              onclick="setValveFlow('${valve.id}', true)" 
                              ${valve.active ? 'disabled' : ''}
                              style="margin: 0; padding: 8px; font-size: 12px;">
                        <i class="fas fa-ban"></i> Close
                      </button>
                    </div>
                  </div>
                `;
              }).join('');
              
              return `
                <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                            color: white; 
                            border-radius: 10px; 
                            padding: 14px; 
                            margin-bottom: 16px;">
                  <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                      <div style="font-size: 12px; opacity: 0.9;">MAIN WATER OUTFLOW</div>
                      <div style="font-size: 28px; font-weight: 700;">${totalOutflow.toFixed(1)} <span style="font-size: 14px;">L/min</span></div>
                    </div>
                    <div style="text-align: right;">
                      <div style="font-size: 12px; opacity: 0.9;">Active Valves</div>
                      <div style="font-size: 24px; font-weight: 700;">${connectedValves.filter(v => !v.active).length}/${connectedValves.length}</div>
                    </div>
                  </div>
                </div>
                ${valveControls}
              `;
            })()}
          </div>

          <div class="card">
            <h4><i class="fas fa-tools"></i> ACTIONS</h4>
            <button class="btn" onclick="editTank('${device.id}')"><i class="fas fa-pen"></i> Edit Tank</button>
            <button class="btn danger" onclick="deleteTank('${device.id}')"><i class="fas fa-trash"></i> Delete</button>
          </div>


          <div class="card">
            <h4><i class="fas fa-clock-rotate-left"></i> HISTORICAL DATA</h4>
            <button class="btn primary" onclick="openHistory('${device.id}', 'tanks')">
              <i class="fas fa-history"></i> View History
            </button>
          </div>
        `;
        const slider = document.getElementById('waterLevelSlider');
        const fill = document.getElementById('waterFill');
        const display = document.getElementById('waterLevelDisplay');
       slider.addEventListener('input', async (e) => {
          const level = parseFloat(e.target.value);
          fill.style.height = `${(level / device.height) * 100}%`; 
          fill.textContent = `${level} m`;
          display.textContent = `${level} m`;
          device.setWaterLevel(level);
          await FirebaseService.saveTank(device);
        });
      } else {
        // VALVE SIDEBAR
        const info = device.info();
        const affectedPipelines = findAffectedPipelines(device);
        const { stats } = calculateHouseholdStats();
        const supplies = calculateSupplyPerHousehold();
        const mainValveData = stats.mainValves.find(m => m.valve.id === device.id);
        const isSubValve = device.category === 'sub';
        const parentValve = isSubValve ? valves.find(v => v.id === device.parentValveId) : null;
        const supplyInfo = supplies.find(s => s.valveId === device.id);
        
        // Get analytics and device telemetry
        const analyticsValve = analyticsState?.valves?.[device.id] || null;
        const valveDeviceTelemetry = analyticsValve?.device || resolveDeviceTelemetry(device);
        
        // Build live metrics object with real or fallback data
        const valveLiveMetrics = {
          battery: valveDeviceTelemetry?.battery !== undefined ? `${valveDeviceTelemetry.battery}%` : (info.battery || 'â€”'),
          pressure: valveDeviceTelemetry?.pressure !== undefined ? `${valveDeviceTelemetry.pressure} PSI` : (info.pressure || 'â€”')
        };
        
        const valveTelemetryDistance = valveDeviceTelemetry?.distance_meters ?? valveDeviceTelemetry?.distanceMeters ?? null;
        const valveDeviceTimestamp = valveDeviceTelemetry?.timestamp ? new Date(valveDeviceTelemetry.timestamp).toLocaleString() : 'â€”';
        
        setText('sidebarTitle', `âš™ï¸ ${device.name}`);
        
        // Build hierarchy HTML
        let hierarchyHTML = '';
        if(mainValveData) {
          hierarchyHTML = `
            <div class="card">
              <h4><i class="fas fa-sitemap"></i> VALVE HIERARCHY</h4>
              <div class="valve-hierarchy">
                <div class="valve-item main ${device.active ? 'closed' : ''}">
                  <div class="valve-item-header">
                    <div class="valve-item-title">
                      <i class="fas fa-cog"></i>
                      ${device.name} (MAIN)
                    </div>
                    <span class="valve-item-status ${device.valveState}">${device.valveState.toUpperCase()}</span>
                  </div>
                  <div class="valve-item-info">${device.households} households total</div>
                </div>
                ${mainValveData.subValves.map(subValve => `
                  <div class="valve-item sub ${subValve.active ? 'closed' : ''}">
                    <div class="valve-item-header">
                      <div class="valve-item-title">
                        <i class="fas fa-cog" style="font-size:16px"></i>
                        ${subValve.name}
                      </div>
                      <span class="valve-item-status ${subValve.valveState}">${subValve.valveState.toUpperCase()}</span>
                    </div>
                    <div class="valve-item-info">${subValve.households} households â€¢ ${subValve.habitation}</div>
                  </div>
                `).join('')}
              </div>
            </div>
          `;
        } else if(isSubValve && parentValve) {
          hierarchyHTML = `
            <div class="card">
              <h4><i class="fas fa-sitemap"></i> VALVE HIERARCHY</h4>
              <div class="valve-hierarchy">
                <div class="valve-item main">
                  <div class="valve-item-header">
                    <div class="valve-item-title">
                      <i class="fas fa-cog"></i>
                      ${parentValve.name} (MAIN)
                    </div>
                    <span class="valve-item-status ${parentValve.valveState}">${parentValve.valveState.toUpperCase()}</span>
                  </div>
                  <div class="valve-item-info">${parentValve.households} households total</div>
                </div>
                <div class="valve-item sub ${device.active ? 'closed' : ''}">
                  <div class="valve-item-header">
                    <div class="valve-item-title">
                      <i class="fas fa-cog" style="font-size:16px"></i>
                      ${device.name} (THIS VALVE)
                    </div>
                    <span class="valve-item-status ${device.valveState}">${device.valveState.toUpperCase()}</span>
                  </div>
                  <div class="valve-item-info">${device.households} households</div>
                </div>
              </div>
            </div>
          `;
        }
        
        // Build household stats HTML
        let householdStatsHTML = '';
        const { valveTree } = calculateHouseholdStats();
        const deviceNode = valveTree.get(device.id);

        if(!device.active && deviceNode) {
          const isMainValve = device.category === 'main';
          const directHouseholds = deviceNode.directHouseholds;
          const totalHouseholds = deviceNode.totalHouseholds;
          const servedHouseholds = deviceNode.servedHouseholds;
          
          householdStatsHTML = `
            <div class="household-stats">
              <h4><i class="fas fa-home"></i> HOUSEHOLD SUPPLY</h4>
              ${isMainValve ? `
                <div class="stat-row" style="background: rgba(255,255,255,0.2); padding: 12px; border-radius: 8px; margin-bottom: 12px;">
                  <span class="label">Total Capacity</span>
                  <span class="value">${totalHouseholds} HH</span>
                </div>
                <div class="stat-row">
                  <span class="label">Direct Households</span>
                  <span class="value">${directHouseholds} HH</span>
                </div>
                <div class="stat-row">
                  <span class="label">Sub-valve Households</span>
                  <span class="value">${totalHouseholds - directHouseholds} HH</span>
                </div>
                <div class="stat-row">
                  <span class="label">Currently Served</span>
                  <span class="value" style="color: #4caf50; font-size: 18px;">${servedHouseholds}/${totalHouseholds} HH</span>
                </div>
              ` : `
                <div class="stat-big">
                  <div class="stat-big-number">${device.households}</div>
                  <div class="stat-big-label">Households Served</div>
                </div>
              `}
              ${supplyInfo ? `
                <div class="stat-row" style="border-top: 2px solid rgba(255,255,255,0.3); padding-top: 12px; margin-top: 12px;">
                  <span class="label">Total Flow Rate</span>
                  <span class="value">${supplyInfo.totalFlow.toFixed(1)} L/min</span>
                </div>
                <div class="stat-row">
                  <span class="label">Per Household</span>
                  <span class="value">${supplyInfo.avgSupply.toFixed(2)} L/min/HH</span>
                </div>
                <div class="stat-row">
                  <span class="label">Daily Supply/HH</span>
                  <span class="value">${(supplyInfo.avgSupply * 60 * 24).toFixed(0)} L/day</span>
                </div>
              ` : ''}
            </div>
          `;
        } else if(device.active) {
          householdStatsHTML = `
            <div class="card" style="background:#fdeaea;border-color:#f7cccc">
              <h4 style="color:var(--danger)"><i class="fas fa-exclamation-triangle"></i> SUPPLY BLOCKED</h4>
              <div style="font-size:13px;color:var(--danger);font-weight:600">
                ${device.households} households are NOT receiving water supply because this valve is CLOSED.
              </div>
            </div>
          `;
        }
        
        // Build complete valve sidebar
        body.innerHTML = `
          <div class="card">
            <h4><i class="fas fa-info-circle"></i> DETAILS</h4>
            <div class="row"><span class="label">ID</span><span class="value">${info.id}</span></div>
            <div class="row"><span class="label">Type</span><span class="value">${info.type}</span></div>
            <div class="row"><span class="label">Category</span><span class="value">${info.category.toUpperCase()}</span></div>
            <div class="row"><span class="label">Households</span><span class="value">${info.households}</span></div>
            <div class="row"><span class="label">State</span><span class="value" style="color:${device.active ? 'var(--danger)' : 'var(--success)'}">${info.valveState.toUpperCase()}</span></div>
          </div>
          ${householdStatsHTML}
          ${hierarchyHTML}
          <div class="card">
            <h4><i class="fas fa-chart-line"></i> LIVE SENSORS <span class="live-indicator"></span></h4>
            <div class="row"><span class="label">Battery</span><span class="value">${valveLiveMetrics.battery}</span></div>
            <div class="row"><span class="label">Pressure</span><span class="value">${valveLiveMetrics.pressure}</span></div>
          </div>
          ${valveDeviceTelemetry ? `
          <div class="card">
            <h4><i class="fas fa-satellite-dish"></i> FIELD DEVICE</h4>
            <div class="row"><span class="label">Device ID</span><span class="value">${valveDeviceTelemetry.id || device.id}</span></div>
            <div class="row"><span class="label">Last Update</span><span class="value">${valveDeviceTimestamp}</span></div>
            ${valveTelemetryDistance !== null ? `<div class="row"><span class="label">Distance</span><span class="value">${valveTelemetryDistance.toFixed(2)} m</span></div>` : ''}
          </div>
          ` : ''}
          <div class="card">
            <h4><i class="fas fa-pipe"></i> AFFECTED PIPELINES (${affectedPipelines.length})</h4>
            ${affectedPipelines.length > 0 ? affectedPipelines.map(pipe => {
              const hasFlow = pipe.currentFlow > 0;
              const isBlocked = device.active;
              return `
                <div class="row" style="border:1px solid ${hasFlow ? '#e3f2fd' : '#ffebee'};border-radius:8px;padding:10px;margin-top:8px;background:${hasFlow ? '#f1f8ff' : '#fff5f5'}">
                  <div style="flex:1">
                    <div style="font-weight:600">${pipe.name}</div>
                    <div style="font-size:11px;color:var(--muted)">${pipe.type} â€¢ ${pipe.diameter}mm</div>
                  </div>
                  <div style="text-align:right">
                    <div style="font-size:16px;font-weight:700;color:${hasFlow ? 'var(--success)' : 'var(--danger)'}">${pipe.currentFlow.toFixed(0)} L/min</div>
                    <div style="font-size:10px;color:${isBlocked ? 'var(--danger)' : 'var(--muted)'}">${isBlocked ? 'â›” BLOCKED' : hasFlow ? 'âœ“ FLOWING' : 'âœ— NO FLOW'}</div>
                  </div>
                </div>
              `;
            }).join('') : '<div style="text-align:center;padding:12px;color:var(--muted);font-size:12px">No pipelines connected</div>'}
          </div>
          <div class="card">
            <h4><i class="fas fa-map-marker-alt"></i> LOCATION</h4>
            <div class="row"><span class="label">Mandal</span><span class="value">${info.loc.mandal}</span></div>
            <div class="row"><span class="label">Habitation</span><span class="value">${info.loc.habitation}</span></div>
            <div class="row"><span class="label">Coordinates</span><span class="value">${info.loc.coords}</span></div>
            <button class="btn primary" onclick="map.setView([${device.lat},${device.lng}],18)"><i class="fas fa-crosshairs"></i> Center on Map</button>
          </div>
          <div class="card">
            <h4><i class="fas fa-sliders"></i> FLOW CONTROL</h4>
            <button class="btn success" onclick="setValveFlow('${device.id}', false)" ${!device.active ? 'disabled' : ''}><i class="fas fa-check"></i> Open Valve</button>
            <button class="btn danger" onclick="setValveFlow('${device.id}', true)" ${device.active ? 'disabled' : ''}><i class="fas fa-ban"></i> Close Valve</button>
          </div>
          <div class="card">
            <h4><i class="fas fa-tools"></i> ACTIONS</h4>
            <button class="btn" onclick="editValve('${device.id}')"><i class="fas fa-pen"></i> Edit Valve</button>
            <button class="btn danger" onclick="deleteValve('${device.id}')"><i class="fas fa-trash"></i> Delete</button>
          </div>
          <div class="card">
            <h4><i class="fas fa-clock-rotate-left"></i> HISTORICAL DATA</h4>
            <button class="btn primary" onclick="openHistory('${device.id}', 'valves')">
              <i class="fas fa-history"></i> View History
            </button>
          </div>
        `;
      }
      sidebar.classList.add('open');
    }

function closeSidebar() { 
  document.getElementById('sidebar').classList.remove('open');
  document.getElementById('supplyDashboard').classList.remove('shifted');
  currentSidebarDeviceId = null;
  currentSidebarDeviceType = null;
}
    async function setValveFlow(id, shouldBlock) {
  const valve = valves.find(v => v.id === id);
  if(!valve) return;
  
  valve.active = shouldBlock;
  valve.valveState = shouldBlock ? 'closed' : 'open';
  await FirebaseService.saveValve(valve);
  
  flowCacheDirty = true;
  requestDrawCanvas();
  requestSupplyDashboardUpdate();
  
  if(shouldBlock) {
    toast(`ðŸ”´ Valve closed - ${valve.households} households affected`);
  } else {
    toast(`âœ… Valve opened - ${valve.households} households restored`);
  }
  
  // Check if tank sidebar is open and refresh it
  const sidebar = document.getElementById('sidebar');
  if(sidebar.classList.contains('open')) {
    const sidebarTitle = document.getElementById('sidebarTitle').textContent;
    if(sidebarTitle.includes('ðŸ—ï¸')) {
      // Tank sidebar is open, find which tank and refresh
      tanks.forEach(tank => {
        if(tank.connectedMainValves && tank.connectedMainValves.includes(valve.id)) {
          showDevice(tank, 'tank');
        }
      });
    }
  }
}

    function findAffectedPipelines(valve) {
      const affected = [];
      pipelines.forEach(pipe => {
        for(let i = 0; i < pipe.points.length - 1; i++) {
          if(pointOnSegment(valve, pipe.points[i], pipe.points[i+1], POINT_R + 4)) {
            affected.push(pipe);
            break;
          }
        }
      });
      return affected;
    }

    function findConnectedPipelines(tank) {
      const connected = [];
      pipelines.forEach(pipe => {
        for(let i = 0; i < pipe.points.length - 1; i++) {
          if(pointOnSegment(tank, pipe.points[i], pipe.points[i+1], 20)) {
            connected.push(pipe);
            break;
          }
        }
      });
      return connected;
    }

    // ==================== FLOW CALCULATION (CACHED) ====================
    function isSegmentBlocked(p1, p2) {
  // A segment is blocked if there's a CLOSED valve (active=true) on it
  return valves.some(v => {
    if (!v.active) return false; // Valve is open, doesn't block
    return pointOnSegment(v, p1, p2, POINT_R + 4);
  });
}

    function connectedSegments(point, excludePi = -1, excludeSi = -1) {
      const results = [];
      pipelines.forEach((pipe, pi) => {
        for(let i = 0; i < pipe.points.length - 1; i++) {
          if(pi === excludePi && i === excludeSi) continue;
          const p1 = pipe.points[i], p2 = pipe.points[i + 1];
          if(distanceInPixels(point, p1) < CONNECT_THRESH || distanceInPixels(point, p2) < CONNECT_THRESH) {
            results.push({pi, si: i});
          }
        }
      });
      return results;
    }

    function computeFlow() {
      if(analyticsState?.pipelines) {
        const flow = {p: {}};
        pipelines.forEach((pipe, pi) => {
          const serverFlow = analyticsState.pipelines[pipe.id];
          if(serverFlow) {
            flow.p[pi] = { s: serverFlow.segments || {} };
            pipe.currentFlow = serverFlow.currentFlow || 0;
          } else {
            pipe.currentFlow = 0;
          }
        });
        flowCache = flow;
        flowCacheDirty = false;
        return flow;
      }

      if(!flowCacheDirty && flowCache) return flowCache;
      const flow = {p: {}};
      if(tanks.length === 0 || pipelines.length === 0) { flowCache = flow; flowCacheDirty = false; return flow; }

      const starts = [];
      tanks.forEach(tank => {
        pipelines.forEach((pipe, pi) => {
          for(let i = 0; i < pipe.points.length - 1; i++) {
            if(pointOnSegment(tank, pipe.points[i], pipe.points[i + 1], 20)) {
              starts.push({pi, si: i});
            }
          }
        });
      });

      if(starts.length === 0) { flowCache = flow; flowCacheDirty = false; return flow; }

      const seen = new Set();
      const queue = [...starts];

     while(queue.length > 0) {
        const current = queue.shift();
        const key = `${current.pi}-${current.si}`;
        if(seen.has(key)) continue;
        seen.add(key);

        const pipe = pipelines[current.pi].points;
        const p1 = pipe[current.si];
        const p2 = pipe[current.si + 1];
        
        // Check if this segment is blocked by a CLOSED valve (active=true)
        const blocked = isSegmentBlocked(p1, p2);

        if(!flow.p[current.pi]) flow.p[current.pi] = {s: {}};
        flow.p[current.pi].s[current.si] = {
          hasFlow: !blocked,  // Flow only if NOT blocked
          blocked: blocked    // True if a closed valve is on this segment
        };
        if(!blocked) {
          if(current.si + 1 < pipe.length - 1) queue.push({pi: current.pi, si: current.si + 1});
          if(current.si - 1 >= 0) queue.push({pi: current.pi, si: current.si - 1});
          [p1, p2].forEach(endpoint => {
            connectedSegments(endpoint, current.pi, current.si).forEach(neighbor => {
              const neighborKey = `${neighbor.pi}-${neighbor.si}`;
              if(!seen.has(neighborKey)) queue.push(neighbor);
            });
          });
        }
      }

      pipelines.forEach((pipe, pi) => {
        if(flow.p[pi]) {
          const flowingSegments = Object.values(flow.p[pi].s).filter(s => s.hasFlow).length;
          const totalSegments = pipe.points.length - 1;
          pipe.currentFlow = totalSegments > 0 ? (flowingSegments / totalSegments) * pipe.capacity : 0;
        } else {
          pipe.currentFlow = 0;
        }
      });
      


      flowCache = flow;
      flowCacheDirty = false;
      return flow;
    }

    // ==================== DRAWING ====================
    let drawRequested = false;
    function requestDrawCanvas() {
      if(drawRequested) return;
      drawRequested = true;
      requestAnimationFrame(() => {
        drawCanvas();
        drawRequested = false;
      });
    }

    function drawCanvas() {
      const now = performance.now();
      if(now - lastDrawTime < DRAW_THROTTLE) return;
      lastDrawTime = now;
      if(!ctx || !map) return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const flow = computeFlow();

      // Pipelines
      // Pipelines
      pipelines.forEach((pipe, pi) => {
        for(let i = 0; i < pipe.points.length - 1; i++) {
          const p1 = pipe.points[i];
          const p2 = pipe.points[i + 1];
          const stat = flow.p[pi]?.s[i];
          const hasFlow = !!stat?.hasFlow;
          const blocked = !!stat?.blocked;
          const connected = stat !== undefined;

          // Default: gray for unconnected segments
          let color = '#b0b9c4';
          let glow = 'rgba(176,185,196,0.4)';
          let lineWidth = LINE_W;
          
          if(connected) {
            if(blocked) { 
              // Red: segment is connected but blocked by a closed valve
              color = '#d32f2f'; 
              glow = 'rgba(211,47,47,0.6)'; 
            }
            else if(hasFlow) { 
              // Blue: segment is connected and has active flow
              color = '#1e88e5'; 
              glow = 'rgba(30,136,229,0.6)'; 
            }
            else {
              // Green/cyan: segment is connected but no flow (no blocking valve, but no water source reaching it)
              color = '#4caf50'; 
              glow = 'rgba(76,175,80,0.4)';
            }
          }
          if(mode === 'erase' && hoveredDevice?.type === 'pipeline') {
            const hoveredPipe = hoveredDevice.data.pipe;
            const hoveredSegment = hoveredDevice.data.segmentIndex;
            if(hoveredPipe.id === pipe.id && hoveredSegment === i) {
              color = '#ff6b6b';
              glow = 'rgba(255,107,107,0.8)';
              lineWidth = LINE_W + 2;
            }
          }

          const a = latLngToPixel(p1);
          const b = latLngToPixel(p2);

          ctx.shadowColor = glow;
          ctx.shadowBlur = 14;
          ctx.strokeStyle = color;
          ctx.lineWidth = lineWidth;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
          ctx.shadowBlur = 0;
        }

        if(pipe.currentFlow > 0 && pipe.points.length > 0) {
          const midPoint = pipe.points[Math.floor(pipe.points.length / 2)];
          const px = latLngToPixel(midPoint);
          ctx.fillStyle = 'rgba(30,136,229,0.9)';
          ctx.font = 'bold 11px Inter, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.shadowColor = 'rgba(0,0,0,0.3)';
          ctx.shadowBlur = 4;
          const flowText = `${pipe.currentFlow.toFixed(0)} L/min`;
          ctx.fillText(flowText, px.x, px.y - 12);
          ctx.shadowBlur = 0;
        }
      });

      // Current pipeline drawing
      if(currentPipeline.length > 1) {
        ctx.strokeStyle = '#9aa7b5';
        ctx.lineWidth = LINE_W;
        ctx.shadowColor = 'rgba(154,167,181,0.5)';
        ctx.shadowBlur = 8;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        const start = latLngToPixel(currentPipeline[0]);
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        for(let i = 1; i < currentPipeline.length; i++) {
          const p = latLngToPixel(currentPipeline[i]);
          ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
        ctx.shadowBlur = 0;
      }

      // Valves
      valves.forEach(valve => {
        const p = latLngToPixel(valve);
        const hovered = hoveredDevice?.device === valve;
        const scale = hovered ? 1.3 : 1.0;
        const size = 32 * scale;
        ctx.shadowColor = valve.active ? 'rgba(211,47,47,0.5)' : 'rgba(106,27,154,0.5)';
        ctx.shadowBlur = 16;
        if(ImageCache.loaded && ImageCache.valve) {
          ctx.drawImage(ImageCache.valve, p.x - size / 2, p.y - size / 2, size, size);
        } else {
          ctx.fillStyle = valve.active ? '#d32f2f' : '#6a1b9a';
          ctx.beginPath(); ctx.arc(p.x, p.y, 12 * scale, 0, Math.PI * 2); ctx.fill();
        }
        ctx.shadowBlur = 0;
        if(valve.households > 0) {
          const badgeRadius = 10 * scale;
          const badgeX = p.x + (size / 2) - badgeRadius;
          const badgeY = p.y - (size / 2) + badgeRadius;
          ctx.fillStyle = valve.active ? '#d32f2f' : '#6a1b9a';
          ctx.beginPath(); ctx.arc(badgeX, badgeY, badgeRadius, 0, Math.PI * 2); ctx.fill();
          ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(badgeX, badgeY, badgeRadius, 0, Math.PI * 2); ctx.stroke();
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 11px Inter, sans-serif';
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText(valve.households, badgeX, badgeY);
        }
      });

      // Tanks
      tanks.forEach(tank => {
        const p = latLngToPixel(tank);
        const hovered = hoveredDevice?.device === tank;
        const scale = hovered ? 1.3 : 1.0;
        const size = 40 * scale;
        ctx.shadowColor = 'rgba(2,136,209,0.5)';
        ctx.shadowBlur = 20;
        if(ImageCache.loaded && ImageCache.waterTower) {
          ctx.drawImage(ImageCache.waterTower, p.x - size / 2, p.y - size / 2, size, size);
        } else {
          ctx.fillStyle = '#0288d1';
          ctx.beginPath(); ctx.arc(p.x, p.y, 14 * scale, 0, Math.PI * 2); ctx.fill();
          ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 3;
          ctx.beginPath(); ctx.arc(p.x, p.y, 14 * scale, 0, Math.PI * 2); ctx.stroke();
        }
        ctx.shadowBlur = 0;
      });
    }

    // ==================== GENERAL UTILS ====================
    function bindBtn(id, fn) {
      const el = document.getElementById(id);
      if(el) el.addEventListener('click', fn);
      else console.warn(`Button with id "${id}" not found`);
    }
    function setActive(id, active) { const el = document.getElementById(id); if(el) el.classList.toggle('active', active); }
    function setText(id, text) { const el = document.getElementById(id); if(el) el.textContent = text; }
    function setValue(id, value) { const el = document.getElementById(id); if(el) el.value = value; }
    function val(id) { const el = document.getElementById(id); return el ? el.value : ''; }
    function openModal(id) { const el = document.getElementById(id); if(el) el.classList.add('active'); }
    function closeModal(id) {
      const el = document.getElementById(id);
      if(el) {
        el.classList.remove('active');
        if(id === 'pipelineModal' && mode === 'pipeline') {
          map.dragging.disable();
          map.scrollWheelZoom.disable();
        }
      }
    }
    function eventToPixel(e) {
      const rect = canvas.getBoundingClientRect();
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }
    function pixelToLatLng(pixel) {
      const point = map.containerPointToLatLng([pixel.x, pixel.y]);
      return {lat: point.lat, lng: point.lng};
    }
    function latLngToPixel(latLng) {
      const point = map.latLngToContainerPoint([latLng.lat, latLng.lng]);
      return {x: point.x, y: point.y};
    }
    function distanceBetweenPixels(p1, p2) { return Math.hypot(p2.x - p1.x, p2.y - p1.y); }
    function distanceInPixels(latLng1, latLng2) {
      const p1 = latLngToPixel(latLng1);
      const p2 = latLngToPixel(latLng2);
      return distanceBetweenPixels(p1, p2);
    }
    function pointOnSegment(point, a, b, threshold) {
      const P = latLngToPixel(point);
      const A = latLngToPixel(a);
      const B = latLngToPixel(b);
      const APx = P.x - A.x, APy = P.y - A.y;
      const ABx = B.x - A.x, ABy = B.y - A.y;
      const ab2 = ABx * ABx + ABy * ABy;
      if(ab2 === 0) return distanceBetweenPixels(P, A) < threshold;
      let t = (APx * ABx + APy * ABy) / ab2;
      t = Math.max(0, Math.min(1, t));
      const proj = { x: A.x + ABx * t, y: A.y + ABy * t };
      return distanceBetweenPixels(P, proj) < threshold;
    }
    function isOnAnyPipeline(latLng, threshold) {
      for(let pipe of pipelines) {
        for(let i = 1; i < pipe.points.length; i++) {
          if(pointOnSegment(latLng, pipe.points[i - 1], pipe.points[i], threshold)) return true;
        }
      }
      return false;
    }

    // ==================== EXPOSE GLOBALS FOR UI CALLBACKS ====================
    window.openHistory = openHistory;
    window.loadHistory = loadHistory;
    window.exportCurrentHistory = exportCurrentHistory;
    window.map = map;
    window.editTank = editTank;
    window.editValve = editValve;
    window.deleteTank = deleteTank;
    window.deleteValve = deleteValve;
    window.deletePipeline = deletePipeline;
    window.editPipeline = editPipeline;
    window.centerPipeline = centerPipeline;
    window.viewTank = viewTank;
    window.viewValve = viewValve;
    window.viewDevice = viewDevice;
    window.setValveFlow = setValveFlow;
    window.switchMapLayer = switchMapLayer;
    
   

  </script>
</body>
</html>
